# 📘 SWEA 알고리즘 풀이

> 싸피의 인재들과 함께하는 SWEA 알고리즘 풀이!! Difficulty 1부터 정복해 나가자!

+ SWEA의 Difficulty 1부터 정답율이 높은순으로 알고리즘 문제를 풀어나가며 정리한 내용들이다.
+ 내가 문제를 어떻게 풀어나갈지 생각한 과정과 스터디를 함께한 동료들의 좋은 코드들이 담겨있다.

**2021-02-11 추가**

+ 백준(BAEKJOON)의 문제들을 단계순으로 풀어나갈 것이다. 
+ 스터디가 아닌 혼자의 힘으로 풀어나가므로 제출 목록에서 다른 사람들의 코드를 보며 학습해나갈 것이다.
+ 이하 commit format
  + SWEA 풀이 - `0000-00-00 TIL D0(0~0)`
  + BAEKJOON 풀이 - `0000-00-00 TIL LV0(0~0)`

**2021-02-13 추가**

+ 싸피 알고리즘학습을 통해 푼 문제들을 정리하며 다양한 풀이를 검토할 것이다.
+ SWEA 홈페이지에서 누구나 접근 가능한 문제들이며, 기존에 스터디에서 진행하던 SWEA 문제 풀이에 더해지는 것들이다.
+ 이하 commit format
  + SWEA 풀이 - `0000-00-00 TIL D0(0~0)`
  + BAEKJOON 풀이 - `0000-00-00 TIL LV0(0~0)`
  + SSAFY알고리즘 풀이 - `0000-00-00 TIL DAY00(D0~D0)`
    + 알고리즘 학습 과정 DAY00의 문제들의, 난이도 범위 D0~D0



## 2021-01-26

+ Difficulty 1의 정답율순 1번 ~ 10번의 문제를 풀었다.

+ `list`의 `.insert()`와 `index`를 활용하여 반복문에서 위치를 바꾸며 요소를 삽입하는 것이 가능하다는 것을 배웠다. 매우 효율적인 것 같다.

+ 공백을 사이에 두고 입력 받은 두 수를 변수에 넣기 위해 `a, b = tuple(map(int, input().split()))`와 같이 써야 할 것 같았지만, `tuple()`을 굳이 안해줘도 `map_object`상태로 두 변수에 대입하는 것이 가능했다.

  가독성과 간결성을 위해 `a, b = map(int, input().split())`으로 쓰자!



## 2021-01-28

+ Difficulty 1의 정답율순 11번 ~ 19번의 문제를 풀었다. Difficulty 1 완료!
+ `round(n, r)`는 `n`을 반올림하여 `r`자리까지 나타내는 함수이다. 이를 직접 구현하고 싶다면 이런 식으로 구현이 가능하다는 것을 알았다.

```python
# avg를 소수 첫 째자리에서 반올림하고 싶을 때

# 원래의 avg에서 정수부(int(avg))를 빼면 소수부만 남고, 이게 0.5보다 크면 반올림한다.
if avg - int(avg) >= 0.5:
    print(f'#{i} {int(avg) + 1}')
else:
    print(f'#{i} {int(avg)}')
```

+ 세상에 `02 == 2`는 안되지만, `int('02') == 2`는 된다. `int('02')`는 2다.

+ 새로운 메서드를 배웠다. `str.rjust(n, char)` => n만큼의 자리를 할애하고 오른쪽 정렬, 빈 공간 char로 채우기
+ 느낀점
  + 만약 if문, elif문 등을 통해서 같은 값을 반환해야 하는 경우가 많이 나오면 구조를 다시 짜보자!
  + if문도 if 안에 if가 들어가는 경우 `and`로 연결할 수 있다는 것을 알았다.



## 2021-02-02

+ Difficulty 2의 정답율순 1번 ~ 2번 문제를 풀었다.
+ 난이도 1이 올라갔다고 정말 매우 어려워졌다.
+ `dict`나 `list`를 사용하여 푸는 것은 코드가 간결해 보이고 실력이 있어 보일 수 있으나, **실제 실행시간과 메모리의 효율성** 측면에서는 **하나하나 코드로 적어내는 것**이 더 빠를 때가 있다는 것을 알았다.
+ 느낀점 및 배운 것들

```python
# 10진수를 2진수로 변환하는 두 가지 방법의 차이점을 보자.
bin(10) 		# '0b1010'이 반환된다. 즉, bin()은 이진수 수식어인 '0b'가 붙는다.
format(10, 'b') # '1010'이 반환된다. bin()과 다르게 깔끔히 숫자 부분만 반환된다.
# 따라서, 문제의 경우에 따라 필요한 것을 골라서 쓸 수 있어야 한다.

# 다른 진수에서 10진수로 바꾸는 방법
int('1010', 2) # int(진수 문자열, 진수)를 통해서 10진수로 변환이 가능하다.

# 문자열 앞에 문자 채워넣기
# 저번에 배웠던 내용이나, 익숙하지가 않아 사용하지 못하였다. 외워두자.
binary += format(ord(c)-65, 'b').rjust(6, '0') # 오른쪽으로 정렬, 6자리 마련, '0'으로 채움
```



## 2021-02-04

+ Difficulty 2의 정답율순 3번 ~ 6번 문제를 풀었다.
+ 저번 보다는 쉬웠으나 민석이의 불면증이 매우 어려웠다.
+ 공백을 기준으로 입력을 받는 것들을 **리스트**가 아닌 **요소**들로 받고 싶을 때는 아래와 같이 직접 받아도 된다.

```python
P, Q, R, S, W = map(int, input().split())
```

+ **펠린드롬** 문제에서 별다른 제약사항이 없다면 빨리 푸는 방법

```python
word == word[::-1] # 단어와 거꾸로 읽은 것이 같은지 확인
```

+ 느낀점 및 배운 것들
  + 함수의 사용 때문에 주력 데이터 구조를 정하면 좋다고 한다.
    + ex) `set`과 `list`를 전부 쓰려다 보면 함수에서 헷갈릴 수 있으니, `list`만 사용하는 연습
  + 중복을 신경쓰지 않고 요소를 세는 방법의 접근
    + `set`을 사용하는 방법
    + `list`와 `.count()`를 사용하는 방법
    + `list`에 미리 전체 요소를 넣어놓고 해당 요소가 나올 때 마다 `.remove()`를 해서 빈 리스트가 될 때까지 하는 방법



## 2021-02-09

+ Difficulty 2의 정답율순 7번 ~ 10번 문제를 풀었다. **(10번은 못풀었다.) SWEA1979 꼭 다시** => **풀었다!**
+ 전체적으로 매우 어려웠다.
+ min과 max를 구하는 문제에서는 `float('inf')`를 활용해도 좋다.

```python
# 초기값 설정
max_num = float('-inf')
min_num = float('inf')
```

+ **그래도 min, max 초기값 설정은 내 SWEA D2_7_1959를 따르자! 이게 제일 좋은 것 같다.**

```python
for문 ~ :
    작업~
    if i == 0:
        max_num = temp_num
    if temp_num > max_num:
        max_num = temp_num
```

+ 구간을 나눠 비교해야 하는 문제는 마냥 index 접근보다는 **slicing**접근도 좋다!
+ 이중배열을 만들 때는 리스트 내포 기능을 사용해도 수월하다.

```python
alist = [list(map(int, input().split())) for i in range(n)]
```

+ 이중배열에서 행과 열의 스위칭에 주의하자(헷갈리지 말자)

```python
for i in range(n):
    for j in range(n):
        alist[i][j] # => 행 접근
        alist[j][i] # => 열 접근
```



## 2021-02-11

+ 백준 1단계 문제의 단계순 1번 ~ 11번 문제를 풀었다. 1단계 완료!
+ 알고리즘의 기초가 되는 사칙연산의 매우 간단한 문제들이었다.
+ **나머지의 특성**과 **정수에서 각 자릿수를 가져오는 방식**이 이번 회의 포인트였다.

```python
# 나머지의 특성
(A+B) % C == ((A%C) + (B%C)) % C
(A*B) % C == ((A%C) * (B%C)) % C
```

```python
# 정수에서 각 자릿수를 가져오는 방식
while num > 0:
    num % 10 # 이게 각 자릿수가 된다.
    num //= 10
```

+ 느낀점 및 배운 것들
  + 기초가 탄탄해야 한다.
  + 앞으로의 모든 알고리즘에서 최대한 내장함수를 사용하지 않을 것이다.
  + 오늘 배운 이 기본 사칙연산들이 알고리즘의 근간이 될 것이다.



## 2021-02-13

+ 백준 2단계 문제의 단계순 1번 ~ 5번 문제를 풀었다. 2단계 완료!
+ if문에 대한 간단한 문제들이었다.
+ **분기를 어떻게 나누는가**는 코드의 길이와 불필요한 실행을 줄이는데에 직결된다.

```python
# x, y의 값을 입력받고 몇 사분면에 위치하는지 찾는 문제
# 단순히 x의 부호와 y의 부호를 하나하나 따져 찾는 방법
A = int(input())
B = int(input())

if A > 0 and B > 0:
    result = 1
elif A > 0 and B < 0:
    result = 4
elif A < 0 and B > 0:
    result = 2
else:
    result = 3
```

```python
# x와 y를 곱한 것을 토대로 찾는 방법
A = int(input())
B = int(input())
if A*B > 0 :
    if A > 0:
        result = 1
    else:
        result = 3
else:
    if A > 0:
        result = 4
    else:
        result = 2
```

+ 후자의 경우 **직관성**은 떨어질 수 있어도 **코드 작성이 줄고 편리하다.**
+ 줄이 더 많아보이는가? 그러나...

```python
# 후자의 코드를 삼항연산자로 표현하면
A = int(input())
B = int(input())
if A*B > 0 :
    result = 1 if A > 0 else 3
else:
    result = 4 if A > 0 else 2
```

+ **삼항연산자**를 사용하면 매우 간단하게 나타낼 수 있다.
+ 전자의 경우는 조건 자체가 길기 때문에 삼항연산자를 사용하더라도 코드가 지저분해진다.



## 2021-02-14

+ 싸피 Day01의 알고리즘 문제들을 복습하였다.
+ Bubble Sort, Counting Sort, 완전 탐색, 탐욕 알고리즘을 배웠다.
+ 버블 정렬

```python
def BubbleSort(arr):
    for i in range(len(arr)-1, 0, -1):
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

+ 카운팅 정렬

```python
def CountingSort(arr, temp, k):
	# arr은 정렬할 리스트
    # temp는 정렬할 리스트의 길이를 갖는 빈 리스트/arr의 복사본
    # k는 arr에서의 최대값
    # C는 카운트 리스트
    C = [0] * (k+1)
    for i in range(len(arr)):
        C[arr[i]] += 1
    
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    for i in range(len(temp), -1, -1):
        temp[C[arr[i]]-1] = arr[i]
        C[arr[i]] -= 1
```

+ 완전 탐색

```python
# 예) {1, 2, 3}을 포함하는 모든 순열을 생성하는 코드(중복 없이)
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i2 and i3 != i1:
                    print(i1, i2, i3)
```

+ 탐욕 알고리즘
  + 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행해 최종적인 해답에 도달
+ 느낀점 및 배운 것들
  + **정렬 알고리즘**은 하나만 알아서는 안되고 상황에 따라 알맞는 것을 사용해야 한다. 다 익숙해지자
  + 아직까지 탐욕 알고리즘은 무엇을 의미하는 것인지 잘 와닿지 않는다.



## 2021-02-16

+ Difficulty 2의 정답율순 11번 ~ 17번 문제를 풀었다. SSAFY과정에서 푼 문제들 제외
+ 또 한번 매우 어려웠다.
+ **이차원 배열**을 활용하는 문제들이 킬링 문제들이었다.
  +  이차원 배열을 만들지 않고 풀 수 있다면 가장 좋다.
  + **직접 배열을 만들려고 들지 마라**
+ 코드의 복잡성을 피하기 위해 **함수화**를 생활화 하자.
+ **중복 검사**에서는 count 리스트를 계속 활용해왔지만 **set**을 사용하는 것이 가장 효율적이다.
+ 이하 중요한 내용들은 전부 코드에 있다.



## 2021-02-17

+ 싸피 Day01의 알고리즘 문제들을 복습하였다.
+ min, max 구현, 슬라이딩 윈도우, 카운트 리스트 활용 등을 배웠다.
+ min, max의 경우 크게 어렵지 않았다. 초기값만 잘 설정한다면 이후는 단순 크기 비교 후 대입의 문제다.
+ 슬라이딩 윈도우의 경우 발상의 전환이 필요하였다. 구간합을 구하는 방법은 두 가지가 있다.

```python
# 구간합 구하기
# arr = 배열, N = arr의 길이, K = 구간의 길이

# 1
# 슬라이딩 윈도우를 활용하지 않고 정말 구간합을 구하기
for i in range(N-K+1):
    range_sum = 0
    for j in range(K):
        range_sum += arr[i+j]
    
    range_sum # 활용
    
# 2
# 슬라이딩 윈도우를 이용해 구간합 구하기
# 나가는 것은 빼고 들어오는 것은 더하는 방식
# 구간합의 초기값을 구하는 작업이 먼저 필요하다.
for i in range(M):
    range_sum += arr[i]
    
for i in range(N-K+1):
    range_sum += arr[i+M-1] - arr[i-1]
    range_sum # 활용
    
# 1의 경우 이중 for문으로 시간복잡도가 커질 수 있다.
# 2의 경우 for문을 두 번 사용하였지만 전부 1단 for문이다.
```

+ **카운트 리스트**의 활용은 **배열**의 문제를 푸는 데에 있어 매우 효과적이다.
  + 특히, **인덱스와 값을 동시에 활용해야 하는 경우**에 매우 강력하다.

```python
arr = [10, 7, 5, 6, 4, 1, 3, 6, 5, 2, 7, 2, 3, 4, 1, 10, 9, 8, 7]
cnt_arr = [0] * (max(arr)+1) # 카운트 리스트는 0번째부터 시작하므로 arr의 최대값 +1 길이만큼 만든다.
for i in range(len(arr)):
    # 각 arr의 요소에 대해 해당 요소 자체가 카운트 리스트의 인덱스가 되고, 해당 인덱스의 카운트 리스트 값을 1씩 증가시킨다.
    cnt_arr[arr[i]] += 1
    
# 이렇게 완성된 카운트 리스트는 최대값, 최소값 문제나 카운팅 정렬 등에 활용되며 여러 역할을 할 수 있다.
```



## 2021-02-18

+ Difficulty 2의 정답율순 18번 ~ 25번 문제를 풀었다. SSAFY과정에서 푼 문제들 제외, **D2 완료!**
+ 역시 난이도가 높았다. 그러나, 배열에 관련된 문제를 많이 풀었어서 그런지 이해는 잘 된다.
+ **배열 활용, 나머지와 정수나눗셈 활용, 정렬, 카운트 리스트, 셀렉션(선택 정렬), 슬라이싱** 등 여러 알고리즘적 기법들을 사용해야 하는 문제들이었다.
+ **리스트에서 일정 구간을 옮겨다니거나/떼와서** 이용해야 하는 경우 **슬라이싱**을 사용하면 정말 편리하다. 복잡하게 가려고 하지말자!
+ **슬라이싱은 범위를 넘어가는 부분까지 참조를해도 요소가 있는 곳 까지만 알아서 잘라서 가져온다.** **(중요)**

```python
# D2_1946번 간단한 압축풀기

T = int(input())
for t in range(1, T+1):
    N = int(input())
    # 모든 알파벳을 주어지는 개수만큼 저장할 리스트
    arr = []
    for i in range(N):
        C, K = input().split()
        K = int(K)
        arr += [C]*K

    print('#%d' % t)
    i = 0
    # 알파벳들을 저장한 리스트에서 10개씩 슬라이싱해서 출력한다. 슬라이싱은 범위가 넘어가면 자동으로 요소가 존재하는 부분까지만 가져온다.
    while len(arr) > i:
        print(''.join(arr[i:i+10]))
        i += 10

# 이 문제에서 arr의 길이는 절대 10의 배수 단위가 아닐 수 있다. 하지만 10씩 끊어서 가져오는 반복문을 반복하면 알아서 10개씩 끊어오다가 마지막에 나머지만큼 끊어서 가져온다.
```

+ 느낀점 및 배운점
  + **제발 문제를 제대로 잘 보자**. 3,6,9 같은 문제는 문제를 제대로 안읽어서 40분을 낭비했다.
  + 슬슬 내장함수를 곁들여서 풀어도 괜찮을 것 같다.
  + 정렬을 오랜만에 다시 접하니 제대로 작성은 했지만 시간이 걸렸다. 더 익숙해지자.

