# 📘 SWEA 알고리즘 풀이

> 싸피의 인재들과 함께하는 SWEA 알고리즘 풀이!! Difficulty 1부터 정복해 나가자!

+ SWEA의 Difficulty 1부터 정답율이 높은 순으로 알고리즘 문제를 풀어나가며 정리한 내용들이다.
+ 내가 문제를 어떻게 풀어나갈지 생각한 과정과 스터디를 함께한 동료들의 좋은 코드들이 담겨있다.



## 2021-01-26

+ Difficulty 1의 정답율 순 1번 ~ 10번의 문제를 풀었다.

+ `list`의 `.insert()`와 `index`를 활용하여 반복문에서 위치를 바꾸며 요소를 삽입하는 것이 가능하다는 것을 배웠다. 매우 효율적인 것 같다.

+ 공백을 사이에 두고 입력 받은 두 수를 변수에 넣기 위해 `a, b = tuple(map(int, input().split()))`와 같이 써야 할 것 같았지만, `tuple()`을 굳이 안해줘도 `map_object`상태로 두 변수에 대입하는 것이 가능했다.

  가독성과 간결성을 위해 `a, b = map(int, input().split())`으로 쓰자!



## 2021-01-28

+ Difficulty 1의 정답율 순 11번 ~ 19번의 문제를 풀었다. Difficulty 1 완료!
+ `round(n, r)`는 `n`을 반올림하여 `r`자리까지 나타내는 함수이다. 이를 직접 구현하고 싶다면 이런 식으로 구현이 가능하다는 것을 알았다.

```python
# avg를 소수 첫 째자리에서 반올림하고 싶을 때

# 원래의 avg에서 정수부(int(avg))를 빼면 소수부만 남고, 이게 0.5보다 크면 반올림한다.
if avg - int(avg) >= 0.5:
    print(f'#{i} {int(avg) + 1}')
else:
    print(f'#{i} {int(avg)}')
```

+ 세상에 `02 == 2`는 안되지만, `int('02') == 2`는 된다. `int('02')`는 2다.

+ 새로운 메서드를 배웠다. `str.rjust(n, char)` => n만큼의 자리를 할애하고 오른쪽 정렬, 빈 공간 char로 채우기
+ 느낀점
  + 만약 if문, elif문 등을 통해서 같은 값을 반환해야 하는 경우가 많이 나오면 구조를 다시 짜보자!
  + if문도 if 안에 if가 들어가는 경우 `and`로 연결할 수 있다는 것을 알았다.



## 2021-02-02

+ Difficulty 2의 정답율 순 1번 ~ 2번 문제를 풀었다.
+ 난이도 1이 올라갔다고 정말 매우 어려워졌다.
+ `dict`나 `list`를 사용하여 푸는 것은 코드가 간결해 보이고 실력이 있어 보일 수 있으나, **실제 실행시간과 메모리의 효율성** 측면에서는 **하나하나 코드로 적어내는 것**이 더 빠를 때가 있다는 것을 알았다.
+ 느낀점 및 배운 것들

```python
# 10진수를 2진수로 변환하는 두 가지 방법의 차이점을 보자.
bin(10) 		# '0b1010'이 반환된다. 즉, bin()은 이진수 수식어인 '0b'가 붙는다.
format(10, 'b') # '1010'이 반환된다. bin()과 다르게 깔끔히 숫자 부분만 반환된다.
# 따라서, 문제의 경우에 따라 필요한 것을 골라서 쓸 수 있어야 한다.

# 다른 진수에서 10진수로 바꾸는 방법
int('1010', 2) # int(진수 문자열, 진수)를 통해서 10진수로 변환이 가능하다.

# 문자열 앞에 문자 채워넣기
# 저번에 배웠던 내용이나, 익숙하지가 않아 사용하지 못하였다. 외워두자.
binary += format(ord(c)-65, 'b').rjust(6, '0') # 오른쪽으로 정렬, 6자리 마련, '0'으로 채움
```



## 2021-02-04

+ Difficulty 2의 정답율 순 3번 ~ 6번 문제를 풀었다.
+ 저번 보다는 쉬웠으나 민석이의 불면증이 매우 어려웠다.
+ 공백을 기준으로 입력을 받는 것들을 **리스트**가 아닌 **요소**들로 받고 싶을 때는 아래와 같이 직접 받아도 된다.

```python
P, Q, R, S, W = map(int, input().split())
```

+ **펠린드롬** 문제에서 별다른 제약사항이 없다면 빨리 푸는 방법

```python
word == word[::-1] # 단어와 거꾸로 읽은 것이 같은지 확인
```

+ 느낀점 및 배운 것들
  + 함수의 사용 때문에 주력 데이터 구조를 정하면 좋다고 한다.
    + ex) `set`과 `list`를 전부 쓰려다 보면 함수에서 헷갈릴 수 있으니, `list`만 사용하는 연습
  + 중복을 신경쓰지 않고 요소를 세는 방법의 접근
    + `set`을 사용하는 방법
    + `list`와 `.count()`를 사용하는 방법
    + `list`에 미리 전체 요소를 넣어놓고 해당 요소가 나올 때 마다 `.remove()`를 해서 빈 리스트가 될 때까지 하는 방법
