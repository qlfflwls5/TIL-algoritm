# 📘 SWEA 알고리즘 풀이

> 싸피의 인재들과 함께하는 SWEA 알고리즘 풀이!! Difficulty 1부터 정복해 나가자!

+ SWEA의 Difficulty 1부터 정답율이 높은순으로 알고리즘 문제를 풀어나가며 정리한 내용들이다.
+ 내가 문제를 어떻게 풀어나갈지 생각한 과정과 스터디를 함께한 동료들의 좋은 코드들이 담겨있다.

**2021-02-11 추가**

+ 백준(BAEKJOON)의 문제들을 단계순으로 풀어나갈 것이다. 
+ 스터디가 아닌 혼자의 힘으로 풀어나가므로 제출 목록에서 다른 사람들의 코드를 보며 학습해나갈 것이다.
+ 이하 commit format
  + SWEA 풀이 - `0000-00-00 TIL D0(0~0)`
  + BAEKJOON 풀이 - `0000-00-00 TIL LV0(0~0)`

**2021-02-13 추가**

+ 싸피 알고리즘학습을 통해 푼 문제들을 정리하며 다양한 풀이를 검토할 것이다.
+ SWEA 홈페이지에서 누구나 접근 가능한 문제들이며, 기존에 스터디에서 진행하던 SWEA 문제 풀이에 더해지는 것들이다.
+ 이하 commit format
  + SWEA 풀이 - `0000-00-00 TIL D0(0~0)`
  + BAEKJOON 풀이 - `0000-00-00 TIL LV0(0~0)`
  + SSAFY알고리즘 풀이 - `0000-00-00 TIL DAY00(D0~D0)`
    + 알고리즘 학습 과정 DAY00의 문제들의, 난이도 범위 D0~D0



## 2021-01-26

+ Difficulty 1의 정답율순 1번 ~ 10번의 문제를 풀었다.

+ `list`의 `.insert()`와 `index`를 활용하여 반복문에서 위치를 바꾸며 요소를 삽입하는 것이 가능하다는 것을 배웠다. 매우 효율적인 것 같다.

+ 공백을 사이에 두고 입력 받은 두 수를 변수에 넣기 위해 `a, b = tuple(map(int, input().split()))`와 같이 써야 할 것 같았지만, `tuple()`을 굳이 안해줘도 `map_object`상태로 두 변수에 대입하는 것이 가능했다.

  가독성과 간결성을 위해 `a, b = map(int, input().split())`으로 쓰자!



## 2021-01-28

+ Difficulty 1의 정답율순 11번 ~ 19번의 문제를 풀었다. Difficulty 1 완료!
+ `round(n, r)`는 `n`을 반올림하여 `r`자리까지 나타내는 함수이다. 이를 직접 구현하고 싶다면 이런 식으로 구현이 가능하다는 것을 알았다.

```python
# avg를 소수 첫 째자리에서 반올림하고 싶을 때

# 원래의 avg에서 정수부(int(avg))를 빼면 소수부만 남고, 이게 0.5보다 크면 반올림한다.
if avg - int(avg) >= 0.5:
    print(f'#{i} {int(avg) + 1}')
else:
    print(f'#{i} {int(avg)}')
```

+ 세상에 `02 == 2`는 안되지만, `int('02') == 2`는 된다. `int('02')`는 2다.

+ 새로운 메서드를 배웠다. `str.rjust(n, char)` => n만큼의 자리를 할애하고 오른쪽 정렬, 빈 공간 char로 채우기
+ 느낀점
  + 만약 if문, elif문 등을 통해서 같은 값을 반환해야 하는 경우가 많이 나오면 구조를 다시 짜보자!
  + if문도 if 안에 if가 들어가는 경우 `and`로 연결할 수 있다는 것을 알았다.



## 2021-02-02

+ Difficulty 2의 정답율순 1번 ~ 2번 문제를 풀었다.
+ 난이도 1이 올라갔다고 정말 매우 어려워졌다.
+ `dict`나 `list`를 사용하여 푸는 것은 코드가 간결해 보이고 실력이 있어 보일 수 있으나, **실제 실행시간과 메모리의 효율성** 측면에서는 **하나하나 코드로 적어내는 것**이 더 빠를 때가 있다는 것을 알았다.
+ 느낀점 및 배운 것들

```python
# 10진수를 2진수로 변환하는 두 가지 방법의 차이점을 보자.
bin(10) 		# '0b1010'이 반환된다. 즉, bin()은 이진수 수식어인 '0b'가 붙는다.
format(10, 'b') # '1010'이 반환된다. bin()과 다르게 깔끔히 숫자 부분만 반환된다.
# 따라서, 문제의 경우에 따라 필요한 것을 골라서 쓸 수 있어야 한다.

# 다른 진수에서 10진수로 바꾸는 방법
int('1010', 2) # int(진수 문자열, 진수)를 통해서 10진수로 변환이 가능하다.

# 문자열 앞에 문자 채워넣기
# 저번에 배웠던 내용이나, 익숙하지가 않아 사용하지 못하였다. 외워두자.
binary += format(ord(c)-65, 'b').rjust(6, '0') # 오른쪽으로 정렬, 6자리 마련, '0'으로 채움
```



## 2021-02-04

+ Difficulty 2의 정답율순 3번 ~ 6번 문제를 풀었다.
+ 저번 보다는 쉬웠으나 민석이의 불면증이 매우 어려웠다.
+ 공백을 기준으로 입력을 받는 것들을 **리스트**가 아닌 **요소**들로 받고 싶을 때는 아래와 같이 직접 받아도 된다.

```python
P, Q, R, S, W = map(int, input().split())
```

+ **펠린드롬** 문제에서 별다른 제약사항이 없다면 빨리 푸는 방법

```python
word == word[::-1] # 단어와 거꾸로 읽은 것이 같은지 확인
```

+ 느낀점 및 배운 것들
  + 함수의 사용 때문에 주력 데이터 구조를 정하면 좋다고 한다.
    + ex) `set`과 `list`를 전부 쓰려다 보면 함수에서 헷갈릴 수 있으니, `list`만 사용하는 연습
  + 중복을 신경쓰지 않고 요소를 세는 방법의 접근
    + `set`을 사용하는 방법
    + `list`와 `.count()`를 사용하는 방법
    + `list`에 미리 전체 요소를 넣어놓고 해당 요소가 나올 때 마다 `.remove()`를 해서 빈 리스트가 될 때까지 하는 방법



## 2021-02-09

+ Difficulty 2의 정답율순 7번 ~ 10번 문제를 풀었다. **(10번은 못풀었다.) SWEA1979 꼭 다시** => **풀었다!**
+ 전체적으로 매우 어려웠다.
+ min과 max를 구하는 문제에서는 `float('inf')`를 활용해도 좋다.

```python
# 초기값 설정
max_num = float('-inf')
min_num = float('inf')
```

+ **그래도 min, max 초기값 설정은 내 SWEA D2_7_1959를 따르자! 이게 제일 좋은 것 같다.**

```python
for문 ~ :
    작업~
    if i == 0:
        max_num = temp_num
    if temp_num > max_num:
        max_num = temp_num
```

+ 구간을 나눠 비교해야 하는 문제는 마냥 index 접근보다는 **slicing**접근도 좋다!
+ 이중배열을 만들 때는 리스트 내포 기능을 사용해도 수월하다.

```python
alist = [list(map(int, input().split())) for i in range(n)]
```

+ 이중배열에서 행과 열의 스위칭에 주의하자(헷갈리지 말자)

```python
for i in range(n):
    for j in range(n):
        alist[i][j] # => 행 접근
        alist[j][i] # => 열 접근
```



## 2021-02-11

+ 백준 1단계 문제의 단계순 1번 ~ 11번 문제를 풀었다. 1단계 완료!
+ 알고리즘의 기초가 되는 사칙연산의 매우 간단한 문제들이었다.
+ **나머지의 특성**과 **정수에서 각 자릿수를 가져오는 방식**이 이번 회의 포인트였다.

```python
# 나머지의 특성
(A+B) % C == ((A%C) + (B%C)) % C
(A*B) % C == ((A%C) * (B%C)) % C
```

```python
# 정수에서 각 자릿수를 가져오는 방식
while num > 0:
    num % 10 # 이게 각 자릿수가 된다.
    num //= 10
```

+ 느낀점 및 배운 것들
  + 기초가 탄탄해야 한다.
  + 앞으로의 모든 알고리즘에서 최대한 내장함수를 사용하지 않을 것이다.
  + 오늘 배운 이 기본 사칙연산들이 알고리즘의 근간이 될 것이다.



## 2021-02-13

+ 백준 2단계 문제의 단계순 1번 ~ 5번 문제를 풀었다. 2단계 완료!
+ if문에 대한 간단한 문제들이었다.
+ **분기를 어떻게 나누는가**는 코드의 길이와 불필요한 실행을 줄이는데에 직결된다.

```python
# x, y의 값을 입력받고 몇 사분면에 위치하는지 찾는 문제
# 단순히 x의 부호와 y의 부호를 하나하나 따져 찾는 방법
A = int(input())
B = int(input())

if A > 0 and B > 0:
    result = 1
elif A > 0 and B < 0:
    result = 4
elif A < 0 and B > 0:
    result = 2
else:
    result = 3
```

```python
# x와 y를 곱한 것을 토대로 찾는 방법
A = int(input())
B = int(input())
if A*B > 0 :
    if A > 0:
        result = 1
    else:
        result = 3
else:
    if A > 0:
        result = 4
    else:
        result = 2
```

+ 후자의 경우 **직관성**은 떨어질 수 있어도 **코드 작성이 줄고 편리하다.**
+ 줄이 더 많아보이는가? 그러나...

```python
# 후자의 코드를 삼항연산자로 표현하면
A = int(input())
B = int(input())
if A*B > 0 :
    result = 1 if A > 0 else 3
else:
    result = 4 if A > 0 else 2
```

+ **삼항연산자**를 사용하면 매우 간단하게 나타낼 수 있다.
+ 전자의 경우는 조건 자체가 길기 때문에 삼항연산자를 사용하더라도 코드가 지저분해진다.



## 2021-02-14

+ 싸피 Day01의 알고리즘 문제들을 복습하였다.
+ Bubble Sort, Counting Sort, 완전 탐색, 탐욕 알고리즘을 배웠다.
+ 버블 정렬

```python
def BubbleSort(arr):
    for i in range(len(arr)-1, 0, -1):
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

+ 카운팅 정렬

```python
def CountingSort(arr, temp, k):
	# arr은 정렬할 리스트
    # temp는 정렬할 리스트의 길이를 갖는 빈 리스트/arr의 복사본
    # k는 arr에서의 최대값
    # C는 카운트 리스트
    C = [0] * (k+1)
    for i in range(len(arr)):
        C[arr[i]] += 1
    
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    for i in range(len(temp), -1, -1):
        temp[C[arr[i]]-1] = arr[i]
        C[arr[i]] -= 1
```

+ 완전 탐색

```python
# 예) {1, 2, 3}을 포함하는 모든 순열을 생성하는 코드(중복 없이)
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i2 and i3 != i1:
                    print(i1, i2, i3)
```

+ 탐욕 알고리즘
  + 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행해 최종적인 해답에 도달
+ 느낀점 및 배운 것들
  + **정렬 알고리즘**은 하나만 알아서는 안되고 상황에 따라 알맞는 것을 사용해야 한다. 다 익숙해지자
  + 아직까지 탐욕 알고리즘은 무엇을 의미하는 것인지 잘 와닿지 않는다.



## 2021-02-16

+ Difficulty 2의 정답율순 11번 ~ 17번 문제를 풀었다. SSAFY과정에서 푼 문제들 제외
+ 또 한번 매우 어려웠다.
+ **이차원 배열**을 활용하는 문제들이 킬링 문제들이었다.
  +  이차원 배열을 만들지 않고 풀 수 있다면 가장 좋다.
  + **직접 배열을 만들려고 들지 마라**
+ 코드의 복잡성을 피하기 위해 **함수화**를 생활화 하자.
+ **중복 검사**에서는 count 리스트를 계속 활용해왔지만 **set**을 사용하는 것이 가장 효율적이다.
+ 이하 중요한 내용들은 전부 코드에 있다.



## 2021-02-17

+ 싸피 Day02의 알고리즘 문제들을 복습하였다.
+ min, max 구현, 슬라이딩 윈도우, 카운트 리스트 활용 등을 배웠다.
+ min, max의 경우 크게 어렵지 않았다. 초기값만 잘 설정한다면 이후는 단순 크기 비교 후 대입의 문제다.
+ 슬라이딩 윈도우의 경우 발상의 전환이 필요하였다. 구간합을 구하는 방법은 두 가지가 있다.

```python
# 구간합 구하기
# arr = 배열, N = arr의 길이, K = 구간의 길이

# 1
# 슬라이딩 윈도우를 활용하지 않고 정말 구간합을 구하기
for i in range(N-K+1):
    range_sum = 0
    for j in range(K):
        range_sum += arr[i+j]
    
    range_sum # 활용
    
# 2
# 슬라이딩 윈도우를 이용해 구간합 구하기
# 나가는 것은 빼고 들어오는 것은 더하는 방식
# 구간합의 초기값을 구하는 작업이 먼저 필요하다.
for i in range(M):
    range_sum += arr[i]
    
for i in range(N-K+1):
    range_sum += arr[i+M-1] - arr[i-1]
    range_sum # 활용
    
# 1의 경우 이중 for문으로 시간복잡도가 커질 수 있다.
# 2의 경우 for문을 두 번 사용하였지만 전부 1단 for문이다.
```

+ **카운트 리스트**의 활용은 **배열**의 문제를 푸는 데에 있어 매우 효과적이다.
  + 특히, **인덱스와 값을 동시에 활용해야 하는 경우**에 매우 강력하다.

```python
arr = [10, 7, 5, 6, 4, 1, 3, 6, 5, 2, 7, 2, 3, 4, 1, 10, 9, 8, 7]
cnt_arr = [0] * (max(arr)+1) # 카운트 리스트는 0번째부터 시작하므로 arr의 최대값 +1 길이만큼 만든다.
for i in range(len(arr)):
    # 각 arr의 요소에 대해 해당 요소 자체가 카운트 리스트의 인덱스가 되고, 해당 인덱스의 카운트 리스트 값을 1씩 증가시킨다.
    cnt_arr[arr[i]] += 1
    
# 이렇게 완성된 카운트 리스트는 최대값, 최소값 문제나 카운팅 정렬 등에 활용되며 여러 역할을 할 수 있다.
```



## 2021-02-18

+ Difficulty 2의 정답율순 18번 ~ 25번 문제를 풀었다. SSAFY과정에서 푼 문제들 제외, **D2 완료!**
+ 역시 난이도가 높았다. 그러나, 배열에 관련된 문제를 많이 풀었어서 그런지 이해는 잘 된다.
+ **배열 활용, 나머지와 정수나눗셈 활용, 정렬, 카운트 리스트, 셀렉션(선택 정렬), 슬라이싱** 등 여러 알고리즘적 기법들을 사용해야 하는 문제들이었다.
+ **리스트에서 일정 구간을 옮겨다니거나/떼와서** 이용해야 하는 경우 **슬라이싱**을 사용하면 정말 편리하다. 복잡하게 가려고 하지말자!
+ **슬라이싱은 범위를 넘어가는 부분까지 참조를해도 요소가 있는 곳 까지만 알아서 잘라서 가져온다.** **(중요)**

```python
# D2_1946번 간단한 압축풀기

T = int(input())
for t in range(1, T+1):
    N = int(input())
    # 모든 알파벳을 주어지는 개수만큼 저장할 리스트
    arr = []
    for i in range(N):
        C, K = input().split()
        K = int(K)
        arr += [C]*K

    print('#%d' % t)
    i = 0
    # 알파벳들을 저장한 리스트에서 10개씩 슬라이싱해서 출력한다. 슬라이싱은 범위가 넘어가면 자동으로 요소가 존재하는 부분까지만 가져온다.
    while len(arr) > i:
        print(''.join(arr[i:i+10]))
        i += 10

# 이 문제에서 arr의 길이는 절대 10의 배수 단위가 아닐 수 있다. 하지만 10씩 끊어서 가져오는 반복문을 반복하면 알아서 10개씩 끊어오다가 마지막에 나머지만큼 끊어서 가져온다.
```

+ 느낀점 및 배운점
  + **제발 문제를 제대로 잘 보자**. 3,6,9 같은 문제는 문제를 제대로 안읽어서 40분을 낭비했다.
  + 슬슬 내장함수를 곁들여서 풀어도 괜찮을 것 같다.
  + 정렬을 오랜만에 다시 접하니 제대로 작성은 했지만 시간이 걸렸다. 더 익숙해지자.



## 2021-02-20

+ 싸피 Day03의 알고리즘 문제들을 복습하였다.
+ 슬라이딩 윈도우, 카운트 리스트 활용 등을 더 배웠다.
+ **횟수, 높이** 등을 묻는 문제에서 **주어진 조건**을 잘보자. **카운트 리스트의 길이**를 파악할 수 있다.
+ 주어진 입력의 순서대로 코드를 처리할 수 있는지를 파악하자. 모든걸 다 저장해놓고 쓰려하지 마라.



## 2021-02-21

+ 싸피 Day04의 알고리즘 문제들을 복습하였다.
+ 2차원 배열, 델타 검색, 모든 부분집합 검색 등을 배웠다.
+ 2차원 배열을 행으로, 열로 자유롭게 다룰 수 있을 때까지 익숙해지는 것이 좋겠다.
+ **델타 검색**의 경우 `drc = [[-1, 0], [1, 0], [0, -1], [0, 1]]`로 설정하는 것이 보통 유용하다.
  + 상, 하, 좌, 우 중 여러 개에 대한 작업을 해야할 때 사용한다.
+ 한 리스트에 대해 **모든 부분집합**을 찾는 방법은 다음과 같다.
  + **비트 연산**을 활용한다.

```python
# arr이 리스트
N = len(arr)
for i in range(1 << N): # i는 0~2^N까지 순회한다. 길이가 N인 집합의 부분집합 개수는 2^N개이다.
    sub_arr = []
    for j in range(N):
        if i & (j << N): # i를 이진수로 표현한 것에 1이 j번째(i의 끝부터)에 있는지 확인하는 것이다.
            sub_arr += [arr[j]] # ex) i의 이진수 표현이 01101일 때 j가 0, 2, 3일 때 1이 있다.
            					# 이때, j번째 요소들이 부분집합의 요소들이 된다.
```

+ 느낀점 및 배운점
  + **나에게 매우 중요한 부분**
    + 달팽이 숫자나 이전의 전기 버스와 같은 경우 나의 풀이법은 항상 '현재 위치에서 어느 규칙을 갖는가'에 집중되어 있었다. => 너무 비효율적일 수 있다.
    + 이보다는 **전체적으로 보았을 때 어떠한 규칙이 성립하는가**를 항상 우선적으로 쳐다보는 것이 좋겠다. 너무 시야가 좁아지지 말자.



## 2021-02-21(2)

+ 싸피 Day05의 알고리즘 문제들을 복습하였다.
+ 비트 연산 활용, 부분집합의 합, 이진탐색, 선택정렬, 2차원 배열 등에 대해 배웠다.
+ 비트 연산의 경우 **분기**나 **switch**의 역할로 활용하기 매우 좋음을 깨달았다.
  + ex) `3 & 1 = 1`, `3 & 2 = 2`, `3 & 1 & 2 = 0`을 활용하여 두 조건이 모두 만족하는지 한 쪽만 만족하는지 등을 판별할 수 있다.
+ 이중 배열을 만들 때는 **얕은 복사**의 개념에 대해 항상 유의를 하여야 한다.
+ 부분집합의 합

```python
# 1~12까지의 숫자 중에서 길이가 N이고 합이 K인 부분집합 찾기

T = int(input())
for t in range(1, T+1):
    N, K = map(int, input().split())
    # 1~12를 담은 리스트 생성
    arr = list(range(1, 13))
    # 조건을 만족하는 부분집합의 개수를 담을 변수 생성
    result = 0
    # 모든 부분집합의 개수에 대하여 각 i번째 부분집합의 i를 이진수로 표현한 것에 1이 N개 들어있는지,
    # 해당 1이 있는 위치를 인덱스로 대응하여 가져온 arr의 값의 합이 K인지를 확인해야 한다.
    for i in range(1 << 12):
        total = 0
        cnt = 0
        # j는 마스크가 되어 i를 2진수로 표현한 것에서의 뒤에서부터 1의 위치를 의미하게 된다.
        for j in range(12):
            if i & (1 << j):
                total += arr[j]
                cnt += 1
            # 효율적으로 하기 위해 조건을 넘어서면 반복 그만. 하지만 이 조건문이 더 비효율적일 수도 있다. 때에 따라 다름부
            if cnt > N or total > K:
                break
                
        if cnt == N and total == K:
            result += 1
            
    print('#%d %d' %(t, result))
```

+ **1~n까지의 숫자에서 부분집합을 따질 때, 부분집합의 길이와 합을 한꺼번에 효율적으로 구할 수 있다!**

```python
sums = [(0, 0)] # 초기값
for num in range(1, N+1):
    sums += [(_cnt+1, _sum+num) for _cnt, _sum in sums]
    # sums는 1부터 N까지의 숫자 리스트의 모든 부분집합의 개수와 합의 쌍을 요소로 갖는다.
```

+ 길이에 따라 부분집합을 나눠서 저장하고 싶을 때

```python
# 예를 들어, lst[1] = [[1], [2], [3] , ... [12]]
# lst[2] = [[1, 2], [1, 3], [1, 4], ... [11, 12]]
lst = [[]*13] # 사전에 미리 제일 긴 부분집합의 길이 + 1개 만큼의 빈 이중배열을 만든다.
lst[len(sub_lst)] += sub_lst # 부분집합을 구한 후 이런식으로 lst에 저장한다.
```

+ 이진 탐색
  + 무조건 정렬되어 있는 시퀀스에 대해서만 가능하다.
  + 중간값을 찾은 후 목표값과 비교하여 중간값을 기준으로 목표값이 있는 쪽만 탐색을 반복하는 알고리즘

```python
# P = 시퀀스, key = 목표값
def binarySearch(P, key):
    start, end = 0, len(P)-1
    while start <= end:
        middle = (start+end)//2
        if middle == key:
            return middle # 목표값의 인덱스를 반환
        elif middle > key:
            end = middle - 1 # middle이 목표값보다 크면 middle 이전부터 다시 탐색
        else:
            start = middle + 1 # middle이 목표값보다 작으면 middle 이후부터 다시 탐색
    return False # 목표값이 없는 경우
```

+ 선택 정렬
  + 내가 원하는 만큼만 정렬을 시행할 수 있다.
  + 최대값, 최소값, 2번째로 큰 값, 2번째로 작은 값, n번째까지 큰/작은 값 등만 찾고싶을 때 유용하다.

```python
def selectionSort(arr):
    N = len(arr)
    for i in range(N):
        min_i = i # 오름차순 정렬을 예시로 하고 있다.
        for j in range(i+1, N):
            if arr[min_i] > arr[j]:
                min_i = j
        
        arr[i], arr[min_i] = arr[min_i], arr[i] # i번째의 값과 i번째 이후의 최소값을 바꾼다.
```

+ 느낀점 및 배운점

  + 대부분의 문제는 막힘없이 풀었으나, 사다리타기의 문제에서 매우 고난을 겪었다.
  + 저번의 느낀점이 똑같은 문제점이었다. **전체적인 규칙이 아닌, 개별 칸에 대한 규칙을 찾으려 했다.**

  + 개별적인 규칙을 찾으려다 보면 **시작과 끝에서 규칙의 예외**가 발생하는 경우가 많다.
  + 따라서, 전체적으로 적용이 가능한 규칙을 찾거나, **패딩**을 넣어주는 것이 좋은 방법이다.



## 2021-02-21(3)

+ 싸피 Day06의 알고리즘 문제들을 복습하였다.
+ 
