# 📘 SWEA 알고리즘 풀이

> 싸피의 인재들과 함께하는 SWEA 알고리즘 풀이!! Difficulty 1부터 정복해 나가자!

+ SWEA의 Difficulty 1부터 정답율이 높은순으로 알고리즘 문제를 풀어나가며 정리한 내용들이다.
+ 내가 문제를 어떻게 풀어나갈지 생각한 과정과 스터디를 함께한 동료들의 좋은 코드들이 담겨있다.

**2021-02-11 추가**

+ 백준(BAEKJOON)의 문제들을 단계순으로 풀어나갈 것이다. 
+ 스터디가 아닌 혼자의 힘으로 풀어나가므로 제출 목록에서 다른 사람들의 코드를 보며 학습해나갈 것이다.
+ 이하 commit format
  + SWEA 풀이 - `0000-00-00 TIL D0(0~0)`
  + BAEKJOON 풀이 - `0000-00-00 TIL LV0(0~0)`

**2021-02-13 추가**

+ 싸피 알고리즘학습을 통해 푼 문제들을 정리하며 다양한 풀이를 검토할 것이다.
+ SWEA 홈페이지에서 누구나 접근 가능한 문제들이며, 기존에 스터디에서 진행하던 SWEA 문제 풀이에 더해지는 것들이다.
+ 이하 commit format
  + SWEA 풀이 - `0000-00-00 TIL D0(0~0)`
  + BAEKJOON 풀이 - `0000-00-00 TIL LV0(0~0)`
  + SSAFY알고리즘 풀이 - `0000-00-00 TIL DAY00(D0~D0)`
    + 알고리즘 학습 과정 DAY00의 문제들의, 난이도 범위 D0~D0

**2021-02-23 추가**

+ 문제 번호만 써져있다보니 문제의 제목을 몰라 나중에 다시 찾아보기 힘들 것 같다.
+ 앞으로는 README에 그날 푼 문제들의 제목을 나열할 것이다. 이전 README도 2021-02-23부로 업데이트 한다.

**2021-04-01 추가**

+ 백준 특강으로 인해 `BAEKJOON_SP`라는 이름으로 백준의 매우 어려운 난이도 문제들을 풀 것이다.
+ 그리고, 이제 백준 문제 풀이는 LV단계가 아닌 티어 기준의 문제들로 풀 것이다.



## 2021-01-26

+ Difficulty 1의 정답율순 1번 ~ 10번의 문제를 풀었다.

+ **스탬프 찍기, 아주 간단한 계산기, 신문 헤드라인, 자릿수 더하기, N줄 덧셈, 1대1 가위바위보, 서랍의 비밀번호, 대각선 출력하기, 간단한 N의 약수, 몫과 나머지 출력하기**

+ **반복, 사칙연산, if문, 나머지** 등에 대해 배웠다.

+ `list`의 `.insert()`와 `index`를 활용하여 반복문에서 위치를 바꾸며 요소를 삽입하는 것이 가능하다는 것을 배웠다. 매우 효율적인 것 같다.

+ 공백을 사이에 두고 입력 받은 두 수를 변수에 넣기 위해 `a, b = tuple(map(int, input().split()))`와 같이 써야 할 것 같았지만, `tuple()`을 굳이 안해줘도 `map_object`상태로 두 변수에 대입하는 것이 가능했다.

  가독성과 간결성을 위해 `a, b = map(int, input().split())`으로 쓰자!



## 2021-01-28

+ Difficulty 1의 정답율순 11번 ~ 19번의 문제를 풀었다. Difficulty 1 완료!
+ **최대수 구하기, 큰 놈, 작은 놈, 같은 놈, 알파벳을 숫자로 변환, 중간값 찾기, 더블더블, 거꾸로 출력해 보아요, 홀수만 더하기, 평균값 구하기, 연월일 달력**
+ **max 구현, 대소 비교, 인덱싱, 날짜 계산** 등을 배웠다.
+ `round(n, r)`는 `n`을 반올림하여 `r`자리까지 나타내는 함수이다. 이를 직접 구현하고 싶다면 이런 식으로 구현이 가능하다는 것을 알았다.

```python
# avg를 소수 첫 째자리에서 반올림하고 싶을 때

# 원래의 avg에서 정수부(int(avg))를 빼면 소수부만 남고, 이게 0.5보다 크면 반올림한다.
if avg - int(avg) >= 0.5:
    print(f'#{i} {int(avg) + 1}')
else:
    print(f'#{i} {int(avg)}')
```

+ 세상에 `02 == 2`는 안되지만, `int('02') == 2`는 된다. `int('02')`는 2다.

+ 새로운 메서드를 배웠다. `str.rjust(n, char)` => n만큼의 자리를 할애하고 오른쪽 정렬, 빈 공간 char로 채우기
+ 느낀점
  + 만약 if문, elif문 등을 통해서 같은 값을 반환해야 하는 경우가 많이 나오면 구조를 다시 짜보자!
  + if문도 if 안에 if가 들어가는 경우 `and`로 연결할 수 있다는 것을 알았다.



## 2021-02-02

+ Difficulty 2의 정답율순 1번 ~ 2번 문제를 풀었다.
+ **간단한 소인수분해, Base64 Decoder**
+ **딕셔너리, 나머지, 아스키코드, 2진수, 비트**에 대해 익힐 수 있었다.
+ 난이도 1이 올라갔다고 정말 매우 어려워졌다.
+ `dict`나 `list`를 사용하여 푸는 것은 코드가 간결해 보이고 실력이 있어 보일 수 있으나, **실제 실행시간과 메모리의 효율성** 측면에서는 **하나하나 코드로 적어내는 것**이 더 빠를 때가 있다는 것을 알았다.
+ 느낀점 및 배운 것들

```python
# 10진수를 2진수로 변환하는 두 가지 방법의 차이점을 보자.
bin(10) 		# '0b1010'이 반환된다. 즉, bin()은 이진수 수식어인 '0b'가 붙는다.
format(10, 'b') # '1010'이 반환된다. bin()과 다르게 깔끔히 숫자 부분만 반환된다.
# 따라서, 문제의 경우에 따라 필요한 것을 골라서 쓸 수 있어야 한다.

# 다른 진수에서 10진수로 바꾸는 방법
int('1010', 2) # int(진수 문자열, 진수)를 통해서 10진수로 변환이 가능하다.

# 문자열 앞에 문자 채워넣기
# 저번에 배웠던 내용이나, 익숙하지가 않아 사용하지 못하였다. 외워두자.
binary += format(ord(c)-65, 'b').rjust(6, '0') # 오른쪽으로 정렬, 6자리 마련, '0'으로 채움
```



## 2021-02-04

+ Difficulty 2의 정답율순 3번 ~ 6번 문제를 풀었다.
+ **지그재그 숫자, 새로운 불면증 치료법, 수도 요금 경쟁, 초심자의 회문 검사**
+ **나머지, 배열, 중복 검사, 카운트, 회문**의 알고리즘을 익혀봤다.
+ 저번 보다는 쉬웠으나 민석이의 불면증이 매우 어려웠다.
+ 공백을 기준으로 입력을 받는 것들을 **리스트**가 아닌 **요소**들로 받고 싶을 때는 아래와 같이 직접 받아도 된다.

```python
P, Q, R, S, W = map(int, input().split())
```

+ **펠린드롬** 문제에서 별다른 제약사항이 없다면 빨리 푸는 방법

```python
word == word[::-1] # 단어와 거꾸로 읽은 것이 같은지 확인
```

+ 느낀점 및 배운 것들
  + 함수의 사용 때문에 주력 데이터 구조를 정하면 좋다고 한다.
    + ex) `set`과 `list`를 전부 쓰려다 보면 함수에서 헷갈릴 수 있으니, `list`만 사용하는 연습
  + 중복을 신경쓰지 않고 요소를 세는 방법의 접근
    + `set`을 사용하는 방법
    + `list`와 `.count()`를 사용하는 방법
    + `list`에 미리 전체 요소를 넣어놓고 해당 요소가 나올 때 마다 `.remove()`를 해서 빈 리스트가 될 때까지 하는 방법



## 2021-02-09

+ Difficulty 2의 정답율순 7번 ~ 10번 문제를 풀었다. **(10번은 못풀었다.) SWEA1979 꼭 다시** => **풀었다!**
+ **두 개의 숫자열, 날짜 계산기, 패턴 마디의 길이, 어디에 단어가 들어갈 수 있을까**
+ **슬라이딩 윈도우, 날짜 계산, 슬라이싱, 이중 배열**의 알고리즘을 배웠다.
+ 전체적으로 매우 어려웠다.
+ min과 max를 구하는 문제에서는 `float('inf')`를 활용해도 좋다.

```python
# 초기값 설정
max_num = float('-inf')
min_num = float('inf')
```

+ **그래도 min, max 초기값 설정은 내 SWEA D2_7_1959를 따르자! 이게 제일 좋은 것 같다.**

```python
for문 ~ :
    작업~
    if i == 0:
        max_num = temp_num
    if temp_num > max_num:
        max_num = temp_num
```

+ 구간을 나눠 비교해야 하는 문제는 마냥 index 접근보다는 **slicing**접근도 좋다!
+ 이중배열을 만들 때는 리스트 내포 기능을 사용해도 수월하다.

```python
alist = [list(map(int, input().split())) for i in range(n)]
```

+ 이중배열에서 행과 열의 스위칭에 주의하자(헷갈리지 말자)

```python
for i in range(n):
    for j in range(n):
        alist[i][j] # => 행 접근
        alist[j][i] # => 열 접근
```



## 2021-02-11

+ 백준 1단계 문제의 단계순 1번 ~ 11번 문제를 풀었다. 1단계 완료!
+ **Hello World출력, 격려의 문구, 고양이, 강아지, 더하기, 빼기, 곱하기, 나누기, 나머지, 곱셈의 과정**
+ 알고리즘의 기초가 되는 **사칙연산**의 매우 간단한 문제들이었다.
+ **나머지의 특성**과 **정수에서 각 자릿수를 가져오는 방식**이 이번 회의 포인트였다.

```python
# 나머지의 특성
(A+B) % C == ((A%C) + (B%C)) % C
(A*B) % C == ((A%C) * (B%C)) % C
```

```python
# 정수에서 각 자릿수를 가져오는 방식
while num > 0:
    num % 10 # 이게 각 자릿수가 된다.
    num //= 10
```

+ 느낀점 및 배운 것들
  + 기초가 탄탄해야 한다.
  + 앞으로의 모든 알고리즘에서 최대한 내장함수를 사용하지 않을 것이다.
  + 오늘 배운 이 기본 사칙연산들이 알고리즘의 근간이 될 것이다.



## 2021-02-13

+ 백준 2단계 문제의 단계순 1번 ~ 5번 문제를 풀었다. 2단계 완료!
+ **두 수 비교하기, 시험 성적, 윤년, 알람시계, 사분면 고르기**
+ **if문**에 대한 간단한 문제들이었다.
+ **분기를 어떻게 나누는가**는 코드의 길이와 불필요한 실행을 줄이는데에 직결된다.

```python
# x, y의 값을 입력받고 몇 사분면에 위치하는지 찾는 문제
# 단순히 x의 부호와 y의 부호를 하나하나 따져 찾는 방법
A = int(input())
B = int(input())

if A > 0 and B > 0:
    result = 1
elif A > 0 and B < 0:
    result = 4
elif A < 0 and B > 0:
    result = 2
else:
    result = 3
```

```python
# x와 y를 곱한 것을 토대로 찾는 방법
A = int(input())
B = int(input())
if A*B > 0 :
    if A > 0:
        result = 1
    else:
        result = 3
else:
    if A > 0:
        result = 4
    else:
        result = 2
```

+ 후자의 경우 **직관성**은 떨어질 수 있어도 **코드 작성이 줄고 편리하다.**
+ 줄이 더 많아보이는가? 그러나...

```python
# 후자의 코드를 삼항연산자로 표현하면
A = int(input())
B = int(input())
if A*B > 0 :
    result = 1 if A > 0 else 3
else:
    result = 4 if A > 0 else 2
```

+ **삼항연산자**를 사용하면 매우 간단하게 나타낼 수 있다.
+ 전자의 경우는 조건 자체가 길기 때문에 삼항연산자를 사용하더라도 코드가 지저분해진다.



## 2021-02-14

+ 싸피 Day01의 알고리즘 문제들을 복습하였다.
+ **babgin, Counting정렬, gravity, view, 순열반복문, 숫자를 정렬하자, 쉬운 거스름돈**
+ **Bubble Sort, Counting Sort, 완전 탐색, 탐욕 알고리즘**을 배웠다.
+ 버블 정렬

```python
def BubbleSort(arr):
    for i in range(len(arr)-1, 0, -1):
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

+ 카운팅 정렬

```python
def CountingSort(arr, temp, k):
	# arr은 정렬할 리스트
    # temp는 정렬할 리스트의 길이를 갖는 빈 리스트/arr의 복사본
    # k는 arr에서의 최대값
    # C는 카운트 리스트
    C = [0] * (k+1)
    for i in range(len(arr)):
        C[arr[i]] += 1
    
    for i in range(1, len(C)):
        C[i] += C[i-1]
    
    for i in range(len(temp), -1, -1):
        temp[C[arr[i]]-1] = arr[i]
        C[arr[i]] -= 1
```

+ 완전 탐색

```python
# 예) {1, 2, 3}을 포함하는 모든 순열을 생성하는 코드(중복 없이)
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i2 and i3 != i1:
                    print(i1, i2, i3)
```

+ 탐욕 알고리즘
  + 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행해 최종적인 해답에 도달
+ 느낀점 및 배운 것들
  + **정렬 알고리즘**은 하나만 알아서는 안되고 상황에 따라 알맞는 것을 사용해야 한다. 다 익숙해지자
  + 아직까지 탐욕 알고리즘은 무엇을 의미하는 것인지 잘 와닿지 않는다.



## 2021-02-16

+ Difficulty 2의 정답율순 11번 ~ 17번 문제를 풀었다. SSAFY과정에서 푼 문제들 제외
+ **가랏! RC카!, 숫자 배열 회전, 스도쿠 검증, 시각 덧셈, 직사각형 길이 찾기**
+ 또 한번 매우 어려웠다.
+ **이차원 배열**을 활용하는 문제들이 킬링 문제들이었다.
  +  이차원 배열을 만들지 않고 풀 수 있다면 가장 좋다.
  + **직접 배열을 만들려고 들지 마라**
+ 코드의 복잡성을 피하기 위해 **함수화**를 생활화 하자.
+ **중복 검사**에서는 count 리스트를 계속 활용해왔지만 **set**을 사용하는 것이 가장 효율적이다.
+ 이하 중요한 내용들은 전부 코드에 있다.



## 2021-02-17

+ 싸피 Day02의 알고리즘 문제들을 복습하였다.
+ **flatten, min/max구하기, 구간합, 소인수분해, 숫자카드, 전기버스, 현주의 상자 바꾸기**
+ **min, max 구현, 슬라이딩 윈도우, 카운트 리스트 활용** 등을 배웠다.
+ min, max의 경우 크게 어렵지 않았다. 초기값만 잘 설정한다면 이후는 단순 크기 비교 후 대입의 문제다.
+ 슬라이딩 윈도우의 경우 발상의 전환이 필요하였다. 구간합을 구하는 방법은 두 가지가 있다.

```python
# 구간합 구하기
# arr = 배열, N = arr의 길이, K = 구간의 길이

# 1
# 슬라이딩 윈도우를 활용하지 않고 정말 구간합을 구하기
for i in range(N-K+1):
    range_sum = 0
    for j in range(K):
        range_sum += arr[i+j]
    
    range_sum # 활용
    
# 2
# 슬라이딩 윈도우를 이용해 구간합 구하기
# 나가는 것은 빼고 들어오는 것은 더하는 방식
# 구간합의 초기값을 구하는 작업이 먼저 필요하다.
for i in range(M):
    range_sum += arr[i]
    
for i in range(N-K+1):
    range_sum += arr[i+M-1] - arr[i-1]
    range_sum # 활용
    
# 1의 경우 이중 for문으로 시간복잡도가 커질 수 있다.
# 2의 경우 for문을 두 번 사용하였지만 전부 1단 for문이다.
```

+ **카운트 리스트**의 활용은 **배열**의 문제를 푸는 데에 있어 매우 효과적이다.
  + 특히, **인덱스와 값을 동시에 활용해야 하는 경우**에 매우 강력하다.

```python
arr = [10, 7, 5, 6, 4, 1, 3, 6, 5, 2, 7, 2, 3, 4, 1, 10, 9, 8, 7]
cnt_arr = [0] * (max(arr)+1) # 카운트 리스트는 0번째부터 시작하므로 arr의 최대값 +1 길이만큼 만든다.
for i in range(len(arr)):
    # 각 arr의 요소에 대해 해당 요소 자체가 카운트 리스트의 인덱스가 되고, 해당 인덱스의 카운트 리스트 값을 1씩 증가시킨다.
    cnt_arr[arr[i]] += 1
    
# 이렇게 완성된 카운트 리스트는 최대값, 최소값 문제나 카운팅 정렬 등에 활용되며 여러 역할을 할 수 있다.
```



## 2021-02-18

+ Difficulty 2의 정답율순 18번 ~ 25번 문제를 풀었다. SSAFY과정에서 푼 문제들 제외, **D2 완료!**
+ **파스칼의 삼각형, 간단한 369게임, 조교의 성적 메기기, 간단한 압축 풀기, 중간 평균값 구하기, 최빈수 구하기, 백만장자 프로젝트**
+ 역시 난이도가 높았다. 그러나, 배열에 관련된 문제를 많이 풀었어서 그런지 이해는 잘 된다.
+ **배열 활용, 나머지와 정수나눗셈 활용, 정렬, 카운트 리스트, 셀렉션(선택 정렬), 슬라이싱** 등 여러 알고리즘적 기법들을 사용해야 하는 문제들이었다.
+ **리스트에서 일정 구간을 옮겨다니거나/떼와서** 이용해야 하는 경우 **슬라이싱**을 사용하면 정말 편리하다. 복잡하게 가려고 하지말자!
+ **슬라이싱은 범위를 넘어가는 부분까지 참조를해도 요소가 있는 곳 까지만 알아서 잘라서 가져온다.** **(중요)**

```python
# D2_1946번 간단한 압축풀기

T = int(input())
for t in range(1, T+1):
    N = int(input())
    # 모든 알파벳을 주어지는 개수만큼 저장할 리스트
    arr = []
    for i in range(N):
        C, K = input().split()
        K = int(K)
        arr += [C]*K

    print('#%d' % t)
    i = 0
    # 알파벳들을 저장한 리스트에서 10개씩 슬라이싱해서 출력한다. 슬라이싱은 범위가 넘어가면 자동으로 요소가 존재하는 부분까지만 가져온다.
    while len(arr) > i:
        print(''.join(arr[i:i+10]))
        i += 10

# 이 문제에서 arr의 길이는 절대 10의 배수 단위가 아닐 수 있다. 하지만 10씩 끊어서 가져오는 반복문을 반복하면 알아서 10개씩 끊어오다가 마지막에 나머지만큼 끊어서 가져온다.
```

+ 느낀점 및 배운점
  + **제발 문제를 제대로 잘 보자**. 3,6,9 같은 문제는 문제를 제대로 안읽어서 40분을 낭비했다.
  + 슬슬 내장함수를 곁들여서 풀어도 괜찮을 것 같다.
  + 정렬을 오랜만에 다시 접하니 제대로 작성은 했지만 시간이 걸렸다. 더 익숙해지자.



## 2021-02-20

+ 싸피 Day03의 알고리즘 문제들을 복습하였다.
+ **두 개의 숫자열, 삼성시의 버스 노선**
+ **슬라이딩 윈도우, 카운트 리스트 활용** 등을 더 배웠다.
+ **횟수, 높이** 등을 묻는 문제에서 **주어진 조건**을 잘보자. **카운트 리스트의 길이**를 파악할 수 있다.
+ 주어진 입력의 순서대로 코드를 처리할 수 있는지를 파악하자. 모든걸 다 저장해놓고 쓰려하지 마라.



## 2021-02-21

+ 싸피 Day04의 알고리즘 문제들을 복습하였다.
+ **2차원 배열_델타 검색, sum, 달팽이 숫자, 부분집합**
+ **2차원 배열, 델타 검색, 모든 부분집합 검색** 등을 배웠다.
+ 2차원 배열을 행으로, 열로 자유롭게 다룰 수 있을 때까지 익숙해지는 것이 좋겠다.
+ **델타 검색**의 경우 `drc = [[-1, 0], [1, 0], [0, -1], [0, 1]]`로 설정하는 것이 보통 유용하다.
  + 상, 하, 좌, 우 중 여러 개에 대한 작업을 해야할 때 사용한다.
+ 한 리스트에 대해 **모든 부분집합**을 찾는 방법은 다음과 같다.
  + **비트 연산**을 활용한다.

```python
# arr이 리스트
N = len(arr)
for i in range(1 << N): # i는 0~2^N까지 순회한다. 길이가 N인 집합의 부분집합 개수는 2^N개이다.
    sub_arr = []
    for j in range(N):
        if i & (j << N): # i를 이진수로 표현한 것에 1이 j번째(i의 끝부터)에 있는지 확인하는 것이다.
            sub_arr += [arr[j]] # ex) i의 이진수 표현이 01101일 때 j가 0, 2, 3일 때 1이 있다.
            					# 이때, j번째 요소들이 부분집합의 요소들이 된다.
```

+ 느낀점 및 배운점
  + **나에게 매우 중요한 부분**
    + 달팽이 숫자나 이전의 전기 버스와 같은 경우 나의 풀이법은 항상 '현재 위치에서 어느 규칙을 갖는가'에 집중되어 있었다. => 너무 비효율적일 수 있다.
    + 이보다는 **전체적으로 보았을 때 어떠한 규칙이 성립하는가**를 항상 우선적으로 쳐다보는 것이 좋겠다. 너무 시야가 좁아지지 말자.



## 2021-02-21(2)

+ 싸피 Day05의 알고리즘 문제들을 복습하였다.
+ **ladder1, 부분집합의 합, 색칠하기, 어디에 단어가 들어갈 수 있을까, 이진탐색, 특별한 정렬, 파리 퇴치**
+ **비트 연산 활용, 부분집합의 합, 이진탐색, 선택정렬, 2차원 배열** 등에 대해 배웠다.
+ 비트 연산의 경우 **분기**나 **switch**의 역할로 활용하기 매우 좋음을 깨달았다.
  + ex) `3 & 1 = 1`, `3 & 2 = 2`, `3 & 1 & 2 = 0`을 활용하여 두 조건이 모두 만족하는지 한 쪽만 만족하는지 등을 판별할 수 있다.
+ 이중 배열을 만들 때는 **얕은 복사**의 개념에 대해 항상 유의를 하여야 한다.
+ 부분집합의 합

```python
# 1~12까지의 숫자 중에서 길이가 N이고 합이 K인 부분집합 찾기

T = int(input())
for t in range(1, T+1):
    N, K = map(int, input().split())
    # 1~12를 담은 리스트 생성
    arr = list(range(1, 13))
    # 조건을 만족하는 부분집합의 개수를 담을 변수 생성
    result = 0
    # 모든 부분집합의 개수에 대하여 각 i번째 부분집합의 i를 이진수로 표현한 것에 1이 N개 들어있는지,
    # 해당 1이 있는 위치를 인덱스로 대응하여 가져온 arr의 값의 합이 K인지를 확인해야 한다.
    for i in range(1 << 12):
        total = 0
        cnt = 0
        # j는 마스크가 되어 i를 2진수로 표현한 것에서의 뒤에서부터 1의 위치를 의미하게 된다.
        for j in range(12):
            if i & (1 << j):
                total += arr[j]
                cnt += 1
            # 효율적으로 하기 위해 조건을 넘어서면 반복 그만. 하지만 이 조건문이 더 비효율적일 수도 있다. 때에 따라 다름부
            if cnt > N or total > K:
                break
                
        if cnt == N and total == K:
            result += 1
            
    print('#%d %d' %(t, result))
```

+ **1~n까지의 숫자에서 부분집합을 따질 때, 부분집합의 길이와 합을 한꺼번에 효율적으로 구할 수 있다!**

```python
sums = [(0, 0)] # 초기값
for num in range(1, N+1):
    sums += [(_cnt+1, _sum+num) for _cnt, _sum in sums]
    # sums는 1부터 N까지의 숫자 리스트의 모든 부분집합의 개수와 합의 쌍을 요소로 갖는다.
```

+ 길이에 따라 부분집합을 나눠서 저장하고 싶을 때

```python
# 예를 들어, lst[1] = [[1], [2], [3] , ... [12]]
# lst[2] = [[1, 2], [1, 3], [1, 4], ... [11, 12]]
lst = [[]*13] # 사전에 미리 제일 긴 부분집합의 길이 + 1개 만큼의 빈 이중배열을 만든다.
lst[len(sub_lst)] += sub_lst # 부분집합을 구한 후 이런식으로 lst에 저장한다.
```

+ 이진 탐색
  + 무조건 정렬되어 있는 시퀀스에 대해서만 가능하다.
  + 중간값을 찾은 후 목표값과 비교하여 중간값을 기준으로 목표값이 있는 쪽만 탐색을 반복하는 알고리즘

```python
# P = 시퀀스, key = 목표값
def binarySearch(P, key):
    start, end = 0, len(P)-1
    while start <= end:
        middle = (start+end)//2
        if middle == key:
            return middle # 목표값의 인덱스를 반환
        elif middle > key:
            end = middle - 1 # middle이 목표값보다 크면 middle 이전부터 다시 탐색
        else:
            start = middle + 1 # middle이 목표값보다 작으면 middle 이후부터 다시 탐색
    return False # 목표값이 없는 경우
```

+ 선택 정렬
  + 내가 원하는 만큼만 정렬을 시행할 수 있다.
  + 최대값, 최소값, 2번째로 큰 값, 2번째로 작은 값, n번째까지 큰/작은 값 등만 찾고싶을 때 유용하다.

```python
def selectionSort(arr):
    N = len(arr)
    for i in range(N):
        min_i = i # 오름차순 정렬을 예시로 하고 있다.
        for j in range(i+1, N):
            if arr[min_i] > arr[j]:
                min_i = j
        
        arr[i], arr[min_i] = arr[min_i], arr[i] # i번째의 값과 i번째 이후의 최소값을 바꾼다.
```

+ 느낀점 및 배운점

  + 대부분의 문제는 막힘없이 풀었으나, 사다리타기의 문제에서 매우 고난을 겪었다.
  + 저번의 느낀점이 똑같은 문제점이었다. **전체적인 규칙이 아닌, 개별 칸에 대한 규칙을 찾으려 했다.**

  + 개별적인 규칙을 찾으려다 보면 **시작과 끝에서 규칙의 예외**가 발생하는 경우가 많다.
  + 따라서, 전체적으로 적용이 가능한 규칙을 찾거나, **패딩**을 넣어주는 것이 좋은 방법이다.



## 2021-02-21(3)

+ 싸피 Day06의 알고리즘 문제들을 복습하였다.
+ **GNS, itoa, String, 고지식한 패턴 검색 알고리즘, 문자열 뒤집기**
+ **문자열, Brute force, itoa/atoi** 등을 배웠다.
+ 문자열을 활용한 문제로는 **문자열 내 패턴 찾기**, **회문 찾기**, **문자열 뒤집기**, **숫자로 변환하기** 등이 있다.
+ 패턴과 관련한 문제에는 **Brute force**, **KMP** 방식을 사용할 수 있다. KMP는 아직 제대로 배우지 않았다.

```python
# Brute Force

# while문
# T = 문자열, P = 패턴
def bruteForce(T, p):
    N = len(T)
    M = len(P)
    i = 0 # 문자열의 인덱스
    j = 0 # 패턴의 인덱스
    
    while i < N and  j < M:
        if T[i] != p[j]:
            # 만약 패턴이 다르다면 i를 반복의 마지막에 패턴 검사 시작 인덱스로 갈 수 있도록 맞춤
            i = i - j
            # 만약 패턴이 다르다면 j를 반복의 마지막에 0이 되도록 -1로 맞춤
            j = -1
        i += 1
        j += 1
    
    # 패턴을 찾아서 검색이 끝났을 때 j의 인덱스는 M이 되어있다. 마지막 인덱스에서 j += 1을 하며 끝나므로
    if j == M:
        return i # 패턴이 시작하는 인덱스
    else:
        return False # 패턴 못찾음
    
    
#  for문
def bruteForce(T, p):
    N = len(T)
    M = len(P)
    for i in range(N-M+1):
        cnt = 0
        for j in range(M):
            if T[i+j] != p[j]:
                break
            else:
                cnt += 1
         if cnt == M:
            return i
    return False
```

+ atoi/itoa
  + atoi: 문자에서 숫자로 바꾸기
  + itoa: 숫자에서 문자로 바꾸기

```python
# 둘 다 모두 ASCII코드를 활용한다.
def atoi(num):
    value = 0
    for i in range(len(num)):
        value *= 10
        value += ord(num[i]) - ord('0')
    
    return value


def itoa(num):
    result = ''
    # 부호
    sign = ''
    if num < 0:
        num = -num
        sign = '-'
    while num > 0:
        result = chr(num%10 + ord('0')) + result
        num //= 10
    
    return sign + result
```



## 2021-02-21(4)

+ 싸피 Day07의 알고리즘 문제들을 복습하였다.

+ **가장 빠른 문자열 타이핑, 글자수, 문자열 비교, 쇠막대기 자르기, 회문 찾기, 회문2**

+ **string, 패턴 찾기, 2차원 배열에서의 회문** 등을 배웠다.

+ **글자수 세기** 같은 경우, **딕셔너리**를 사용하면 굉장히 간편하다.

  + `dict.fromkeys(arr, 초기값)`을 통해 쉽게 각 글자에 대한 딕셔너리를 만들자

+ **패턴 찾기**의 경우에도, **count 메서드**를 사용할 수 있다면 매우 간편하게 해결할 수 있다.

  + `if string.count(pattern): return 1`을 통해 count가 1이상이면 있다고 반환한다.

+ 이중 배열에서 회문 찾기의 경우, 회문을 검사하는 작업을 각 행과 각 열에서 실시한다고 생각하면 된다.

  회문의 길이(M)이 주어져 있는 경우

```python
def palindrome(row, N, M):
    result = ''
    for j in range(N-M+1):
        for k in range(M//2):
            if row[j+k] != row[j+M-1-k]:
                break
        else:
            result = ''.join(row[j:j + M])

    return result


T = int(input())
for t in range(1, T+1):
    # N = arr의 길이 M = 팰린드롬의 길이
    N, M = map(int, input().split())
    arr = [list(input()) for _ in range(N)]
    ans = ''
    while not len(ans):
        for i in range(N):
            ans = palindrome(arr[i], N, M) + palindrome(list(zip(*arr))[i], N, M)
            if ans:
                break

    print('#%d %s' %(t, ans))
```

​	회문의 길이가 주어져 있지 않은 경우

```python
# 일반적인 풀이
def my_find(M):
    # 전체크기가 N이다.
    for i in range(N):
        for j in range(N - M + 1):
            # 스왑 통한 회문 검사
            # 가로 검사
            for k in range(M // 2):
                # 앞뒤검사
                if words[i][j + k] != words[i][j + M - 1 - k]:
                    break
                # 회문임
                elif k == M // 2 - 1:
                    return M
            # 세로 검사
            for k in range(M // 2):
                if words[j + k][i] != words[j + M - 1 - k][i]:
                    break
                elif k == M // 2 - 1:
                    return M
    return 0


for _ in range(10):
    tc_num = int(input())

    N = 100
    words = [input() for i in range(N)]

    # 가장 길이가 긴 회문부터 검사를 한다.
    for i in range(N, 0, -1):
        ans = my_find(i)

        if ans:
            break

    print('#{} {}'.format(tc_num, ans))
    
    
# 속도가 빠른 내 풀이
# 풀이한 논리
# 팰린드롬은 결국 '중심 문자'로부터 양옆으로 뻗어져나갈 때 양옆이 같은 문자열이다. (중심 문자에 대한 정의는 center_palindrome함수 내에 있다)
# 그러므로, 중심 문자를 구하는 부분과 그를 기준으로 양옆으로 뻗어져 나가며 팰린드롬을 구하는 부분으로 나뉘어 작동하는 방식이다.

# 한 문자열, 문자열의 길이, 팰린드롬을 검사할 인덱스를 인자로 받는다.
def center_palindrome(string, N, i):
    # 이하 center는 현재 i번째의 문자이며 '중심 문자'란 center가 반복되는 총 문자를 말한다. 예를 들어, 'ABBBA'에 i가 2라면 center는 'B', 중심 문자는 'BBB'이다.
    center = string[i]
    # center의 양 옆에서 시작, temp_i는 왼쪽으로 나아갈 것이고 temp_j는 오른쪽으로 나아갈 것이며, temp_len은 중심 문자의 총 길이다.
    temp_i, temp_j, temp_len = i - 1, i + 1, 1
    # 나아가다 끝에 도달하면 더 이상 나아가지 말아야 하므로 각각 temp_i와 temp_j의 플래그를 만든다. temp_i는 0에, temp_j는 N-1에 도달하면 끝까지 간 것이다.
    is_i_end, is_j_end = 0, 0
    while True:
        # 중심 문자의 왼쪽 문자(string[temp_i])가 center와 같다면 중심 문자의 길이를 1 늘리고 temp_i를 왼쪽 칸으로 옮긴다.
        if string[temp_i] == center and not is_i_end:
            # temp_i가 0이면서 0번째 문자가 center와 같다면 중심 문자의 길이만 1 늘려주고 is_i_end를 1로 바꿔 이후 temp_i에 대한 작업은 종료한다.
            if temp_i == 0:
                is_i_end = 1
                temp_len += 1
            else:
                temp_i -= 1
                temp_len += 1
        # 중심 문자의 오른쪽 문자(string[temp_j)가 center와 같다면 중심 문자의 길이를 1 늘리고 temp_j를 오른쪽 칸으로 옮긴다.
        if string[temp_j] == center and not is_j_end:
            # temp_j가 N-1이면서 N-1번째 문자가 center와 같다면 중심 문자의 길이만 1 늘려주고 is_j_end를 1로 바꿔 이후 temp_j에 대한 작업은 종료한다.
            if temp_j == N-1:
                is_j_end = 1
                temp_len += 1
            else:
                temp_j += 1
                temp_len += 1
        # 매 temp_i, temp_j에 대한 작업에서 중심 문자의 탐색이 끝나는 세 가지 경우의 수가 있다. 양 끝에 도달하지 않은 채로 끝난 경우, 한 쪽이 끝에 도달해서 끝난 경우
        # 전자의 경우 현재 temp_i와 temp_j번째 문자가 center와 다른 경우이다. 예) ABBBA에서 temp_i, temp_j는 각각 왼쪽 A, 오른쪽 A의 인덱스가 된다.
        # 후자의 경우 끝에 도달하지 않은 쪽의 문자가 center와 다른 경우이다. 예) ABBBB에서 temp_i는 A의 인덱스가 되고, BBBBA라면 temp_j는 A의 인덱스가 된다.
        # 각 경우에서 temp_i가 중심 문자의 시작, temp_j가 중심문자의 끝 번째가 되도록 조정한다.
        if string[temp_i] != center and string[temp_j] != center:
            temp_i += 1
            temp_j -= 1
            break
        elif temp_i == 0 and string[temp_j] != center:
            temp_j -= 1
            break
        elif temp_j == N-1 and string[temp_i] != center:
            temp_i += 1
            break

    return temp_i, temp_j, temp_len


# 중심 문자로부터 양옆으로 뻗어나가 팰린드롬을 검사할 함수
def max_palindrome(string):
    N = len(string)
    max_len = 0
    i = 1
    while i < N-1:
        temp_i, temp_j, temp_len = center_palindrome(string, N, i)
        # i를 중심 문자의 + 1번째로 계속 이동한다. 불필요한 반복을 줄일 수 있다.
        # 예) BBBABC가 있을 때, 첫 번째 B에서의 팰린드롬 검사를 실시했다면, 이후 중심 문자 내 연속되는 B에서는 검사를 안해도 된다. 다음 검사는 A부터 한다.
        i = temp_j + 1

        while 0 < temp_i and temp_j < N - 1:
            temp_i -= 1
            temp_j += 1
            if string[temp_i] != string[temp_j]:
                break
            temp_len += 2

        if max_len < temp_len:
            max_len = temp_len

    return max_len


for t in range(1, 11):
    n = int(input())
    arr_row = [input() for _ in range(100)]
    max_result = 0
    # 입력으로 받은 이중배열과 열 기준으로 바꾼 이중배열을 하나씩 가져와서
    for arr in arr_row, zip(*arr_row):
        # 해당 이중배열의 문자열을 하나씩 가져와서 가장 긴 팰린드롬의 길이를 구하기
        for string in arr:
            temp_result = max_palindrome(string)
            if max_result < temp_result:
                max_result = temp_result

    print('#%d %d' % (t, max_result))
```

+ 쇠막대기 자르기 문제는 매우 재밌는 문제였는데, 이런 문제일수록 규칙을 찾아내는 것이 중요하다.
+ 느낀점 및 배운점
  + 이중 배열에서의 회문찾기가 매우 어려웠다.
  + 특히, 회문의 길이가 정해져있지 않은 경우, **나는 조금 색다른 풀이를 하였는데** 이 방법은 회문의 길이가 짧을수록 효율이 좋으며, 회문의 길이가 길다하더라고 일반적인 방법보다 조금 비효율적이므로 평균적으로 효율적인 코드라고 할 수 있다.



## 2021-02-21(5)

+ 싸피 Day08의 알고리즘 문제들을 복습하였다.
+ **숫자 배열 회전, 어디에 단어가 들어갈 수 있을까, 의석이의 세로로 말해요**
+ 2차원 배열의 회전, 각 행의 길이가 다른 2차원 배열 등을 배웠다.
+ 2차원 배열의 회전과 같은 경우 두 가지 풀이가 있을 수 있다.
  + 정말 배열을 회전시키기
  + 배열이 회전되었을 때에 값이 어디로 이동하는지를 파악해 인덱싱을 이용해 값만 빼오기

```python
# 숫자 배열 회전 문제

# 배열 자체를 회전시키는 풀이
# 배열을 90도 회전시키는 함수
def shift90(arr):
    # 이중 배열은 깊은 복사가 힘들기때문에 아예 새로운 배열을 만들어 버린다.
    new_arr = [[0] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            new_arr[c][N - r - 1] = arr[r][c]
    return new_arr


T = int(input())

for tc in range(1, T + 1):
    N = int(input())

    nums = [list(map(int, input().split())) for _ in range(N)]

    num_90 = shift90(nums)
    num_180 = shift90(num_90)
    num_270 = shift90(num_180)

    print('#%d' % tc)
    for i in range(N):
        print(''.join(map(str, num_90[i])), ''.join(map(str, num_180[i])), ''.join(map(str, num_270[i])))
        
  
# 회전되었을 때의 값만 빼오는 풀이
T = int(input())
for t in range(1, T+1):
    N = int(input())
    print('#%d' % t)
    arr = [list(map(int, input().split())) for _ in range(N)]
    # 진짜로 90도, 180도, 270도 돌리지 말고 각 행에 출력되는 값을 어떻게 뽑아올 수 있는지 생각해보자
    # 각 i번째 행에 대하여 90도로 돌린 i번째 행, 180도로 돌린 i번째 행, 270도로 돌린 i번째 행을 출력하면 되는 것이다.
    # 즉, 90도 180도 270도 돌리면 각각 어느 요소가 어디로 이동하는지의 규칙을 찾으면 된다.
    for i in range(N):
        result = ''
        for j in range(N):
            result += str(arr[N-j-1][i])
        result += ' '
        for j in range(N):
            result += str(arr[N-i-1][N-j-1])
        result += ' '
        for j in range(N):
            result += str(arr[j][N-i-1])

        print(result)
```

+ 행의 길이가 서로 다를 때 열을 읽는 방법에는 다음과 같은 방법이 있다.
  + 제일 긴 행을 기준으로 하여 짧은 행들이 그 길이에 맞춰질 때까지 공백 데이터를 추가
  + 제일 긴 행의 길이를 갖는 리스트를 만들어 리스트 인덱스에 대응하는 행의 값들을 가져오기

```python
# 제일 긴 행을 기준으로 하여 짧은 행들이 그 길이에 맞춰질 때까지 공백 데이터를 추가 
T = int(input())
for t in range(1, T+1):
    N = 5
    data_arr = [list(input()) for _ in range(N)]
    
    # 가장 긴 길이를 찾는다. data_arr을 가장 긴 길이 * 가장 긴 길이 형태로 만들기 위해
    max_i = 0
    for i in range(N):
        if len(data_arr[max_i]) < len(data_arr[i]):
            max_i = i

    # 모든 row에 대하여 길이가 가장 긴 것에 맞춰질 때까지 공백을 삽입한다.
    for data in data_arr:
        while len(data) < len(data_arr[max_i]):
            data += ['']

    # 세로로 읽어와 result에 저장한다.
    result = ''
    for col in zip(*data_arr):
        for i in range(N):
            result += col[i]

    print('#%d %s' %(t, result))
    
    
# 제일 긴 행의 길이를 갖는 리스트를 만들어 리스트 인덱스에 대응하는 행의 값들을 가져오기
for t in range(1, int(input())+1):
    # 어차피 주어지는 글자는 15자 이하라고 하였다.
    result = ['']*15
    for _ in range(5):
        word = input()
        for i in range(len(word)):
            # result의 i번째에 각 줄의 i번째 문자가 차례로 들어간다!
            result[i] += word[i]

    print('#%s %s' % (t, ''.join(result)))
```



## 2021-02-23

+ Difficulty 3의 정답율순 1번 ~ 5번 문제를 풀었다.
+ **준환이의 운동관리, 거듭 제곱(재귀), 회문1, 암호문3, 모음이 보이지 않는 사람**
+ **조건표현식, 재귀, 이중 배열, 회문, string, 슬라이싱** 등의 알고리즘적 기법들을 사용해야 하는 문제들이었다.
+ 회문을 찾는 경우 `N-M+1`이라는 것과 `arr[i][j+k] != arr[i][j+M-1-k]`가 정말 자주 쓰일 것이다.
  + 혹은 `arr[i+j] != arr[i+M-1-j]`

```python
# D3_1215번 회문1

# 한 행에 대해 길이가 M인 팰린드롬의 개수를 찾는 함수
def palindrome(string):
    cnt = 0
    for i in range(N-M+1):
        for j in range(M//2):
            if string[i+j] != string[i+M-1-j]:
                break
        else:
            cnt += 1

    return cnt


for t in range(1, 11):
    # N = 정사각형 이중배열 한 변의 길이, M = 회문의 길이
    N, M = 8, int(input())
    arr = [input() for _ in range(N)]
    cnt = 0
    for i in range(N):
        # 가로 검사와 세로 검사를 차례로 하겠다. zip(*arr)을 통해 행열을 전환한다.
        for temp_arr in arr, zip(*arr):
            # 다만 zip(*arr)에서 가져오는 string은 사실 type이 tuple이다.
            for string in temp_arr:
                cnt += palindrome(string)

    print('#%d %d' %(t, cnt))
```

+ 느낀점 및 배운점
  + **제발 문제를 제대로 잘 보자**. 암호문3도 어렵지 않은데 fail을 한 번 했다.
  + 그 외에 문제적으로 어려운 것은 딱히 없었다.
  + `zip`에 대한 특성을 한 번 idle을 통해 알아보았다.

```python
>>> arr = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

>>> zip(*arr)
<zip object at 0x0000020C7D49BC40>

>>> for row in zip(*arr):
    print(row)

(0, 0, 0)
(0, 0, 0)
(0, 0, 0)

>>> for row in zip(*arr):
    print(type(row), row)
    
<class 'tuple'> (0, 0, 0) # zip의 내용물은 전부 타입이 tuple로 되어있다.
<class 'tuple'> (0, 0, 0)
<class 'tuple'> (0, 0, 0)

>>> type(zip(*arr))
<class 'zip'>

>>> zip(*arr)[0] # 가장 신기한 부분은 zip이 iterable하면서, 인덱싱은 안된다는 것이다. generator의 특성인 것일까?
Traceback (most recent call last):
  File "<pyshell#34>", line 1, in <module>
    zip(*arr)[0]
TypeError: 'zip' object is not subscriptable
```



## 2021-02-25

+ 삼성 소프트웨어 역량 시험 IM대비로 기존에 풀었던 문제들을 리뷰했다.
+ **영준이의 카드 카운팅, 오목 판정, 원재의 메모리 복구하기, 퍼펙트 셔플, 농작물 수확하기, 쇠막대기 자르기, 백만장자 프로젝트, 자기 방으로 돌아가기, 진기의 최고급 붕어빵, 재미있는 오르셀 게임**

+ 이중 배열에 있어서 인덱스를 계산하는 것이 매우 까다롭고 실수할 여지가 많다. **실제 손으로 써가며 풀어보자.**

+ 이제 대부분의 알고리즘 문제들은 단순히 문제의 흐름대로 코드를 쭉 짜기보다는 그 속에서 숨어있는 규칙을 찾거나 가장 효율적인 알고리즘을 찾아야 한다.
  + 백만장자 프로젝트 같은 경우, 주어진 데이터를 거꾸로 읽어야 효율적이다.
  + 붕어빵의 경우 실제 문제의 상황을 코드로 구현하는 것이 아니라, 답을 빠르게 구할 수 있도록 상황을 정리하여 코딩해야 한다.
  + 오르셀과 같은 경우, 게임을 코드로 구현해야 하는데 말로 풀어놓은 게임 규칙을 그대로 코드에 어떻게 가장 효율적으로 구현할 수 있는가를 생각해야 했다.



## 2021-02-26

+ 싸피 Day09의 알고리즘 문제들을 복습하였다.

+ **괄호 검사, 그래프를 저장하는 법, 재귀-피보나치, 파스칼의 삼각형**

+ **스택, 인접행렬, 인접리스트, 재귀** 등의 알고리즘적 기법들을 사용해야 하는 문제들이었다.

+ DFS를 배우기 위한 전초 작업으로써 스택을 자세히 배우고, 주어지는 정점과 간선을 이용해 인접행렬과 인접리스트를 만드는 법을 배웠다.

+ 재귀는 개념은 알아도 그것이 실제로 어떻게 작동을 하는지 가늠하기가 매우 어려웠다.

+ 느낀점 및 배운점

  + 앞으로 재귀에서 발목이 많이 잡힐 것 같다.

  

## 2021-03-02

+ Difficulty 3의 정답율순 6번 ~ 10번 문제를 풀었다. 6번은 SSAFY과정 중 완료했다.
+ **암호 생성기, 소득불균형, Magnetic, 쥬스 나누기**
+ **스택, 이중 배열, 사칙연산** 등의 알고리즘적 기법들을 사용해야 하는 문제들이었다.
+ 이번 회차의 큰 중점은 바로 **CT**에 있었다. 
  + 문제들의 코드는 전혀 어렵지 않았다. 대신, **문제를 푸는 법**을 찾아내야 풀 수 있는 문제들이었다.
  + 오늘은 알고리즘보다는 **컴퓨팅 사고력**을 키울 수 있었던 것 같다.

+ Magnetic 문제는 어려워 보이기도 하고 주어진 데이터도 엄청 컸지만, 결국 내가 필요한 숫자 몇 개만 따지면 바로 답이 구해지는 문제였다.
+ 암호생성기의 싸이클을 돌리는 문제도 마찬가지다. 싸이클에 관해서 나오는 문제는 결국 **싸이클을 몇 번 돌았을 때 제자리로 돌아오는가**를 찾는 것이 관건이다. 이 문제 역시 그런 규칙이 숨어있었다.

+ 느낀점 및 배운점
  + 문제를 제대로 보지 못해서 생긴 실수들이 많았는데, 이번에 오히려 컴퓨팅 사고력적 문제들이 나오면서 문제에 집중해볼 수 있는 시간이 되었던 것 같다.
  + 중간중간 이런 문제들이 나오면서 환기도 시키며 문제를 읽는 중요성을 다시 한 번 깨우치면 좋을 것 같다.



## 2021-03-04

+ Difficulty 3의 정답율순 11번 ~ 17번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **다솔이의 다이아몬드 장식, 제곱 팰린드롬 수, 보충학습과 평균, 단순 2진 암호코드**
+ **문자열, 회문, 사칙연산, 규칙 찾기** 등의 알고리즘적 기법들을 사용해야 하는 문제들이었다.
+ 이번 회차 또한 알고리즘을 사용한다기 보다는 사고력쪽의 문제들이었던 것 같다. 어렵지 않았다.
+ 느낀점 및 배운점
  + 이제는 코드를 간단하게 정리하는 것도 신경써야 할 때다.



## 2021-03-06

+ 싸피 Day10의 알고리즘 문제들을 복습하였다.
+ **그래프 경로, 길찾기, 반복문자 지우기, 백만장자 프로젝트, 비밀번호, 종이 붙이기**
+ **스택, DFS, DP 맛보기** 등의 알고리즘적 기법들을 사용해야 하는 문제들이었다.
+ 이제부터 슬슬 여러 답 속에 진정한 답이 숨어져 있는 문제들이 자주 등장하는 것 같다.
  + 다른 시각에서 풀었을 때 / 내가 보조 자료를 만들어냈을 때 훨씬 효율적이고 쉬운 코딩이 가능한 문제

+ 느낀점 및 배운점
  + 스택과 기본적인 DFS를 알고 있으면 풀이가 가능한 문제들이었다.
  + 이정도의 기본 스택, DFS 사용 문제는 어렵지 않다.



## 2021-03-09

+ Difficulty 3의 정답율순 18번 ~ 32번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **민석이의 과제 체크하기, 홀수일까 짝수일까, USB 꽂기의 미스터리, 최대 성적표 만들기, 영준이와 신비한 뿔의 숲, 구독자 전쟁, 2016년 요일 맞추기, 두가지 빵의 딜레마**
+ 알고리즘이라기보다는 **수학적인 풀이**였다.
+ 어렵지 않은 수학 능력을 요구하는 문제들이었으므로 어렵지 않았다.
+ 느낀점 및 배운점
  + 지금의 문제들은 수학적인 풀이 그 자체만을 물어보는 문제이기 때문에 푸는 데 어렵지 않다.
  + 하지만 이러한 것들이 기존의 난이도가 높았던 알고리즘 문제에 접합되어 섞여 나온다면 굉장히 고난이도의 문제로 변할 수 있을 것 같기 때문에, 지금 난이도가 낮다 하더라고 쉽게 넘기지 않고 수학적인 풀이들을 익혀야겠다는 생각이 들었다.



## 2021-03-11

+ 삼성 소프트웨어 역량 시험 A형 모의평가 대비 문제를 풀었다. SSAFY D4 난이도급 문제들이다.
+ **수영장, 요리사**
+ **DFS, DP, 조합** 등의 알고리즘 기법들을 사용해야 하는 문제들이었다.
+ A형 대비 문제라 그런지 DFS, DP, 조합 등을 이용해야 해서 난이도가 매우 높았다.
+ 스터디 내에서도 두 문제를 전부 푼 사람은 나 포함 두 명 밖에 없었다.
+ 수영장
  + DFS로 풀이한 경우: 가지치기를 매우 잘 해야 하는 문제였다. 요소를 하나하나 따져 더 이상 나아가지 않아도 되는 길은 탐색하지 않는 것이 시간 절약의 관건이다.
  + DP로 풀이한 경우: 나는 DP로 풀이하지 못하였다. DP의 경우 무조건 이전의 시행들과 관련하여 규칙을 짜는 것이므로, 이후의 시행을 신경쓴다거나 하지 말자. DP를 배우지 않은 상태라 이부분이 헷갈려 풀지 못하였다.

```python
# DFS
# 1 ~ 12월을 인덱스 상 0 ~ 11월로 볼 것이다.
def cost(month, S):
    # 가지치기1: 이번 달에 수영장을 가지 않으면 바로 다음 달로 넘어가기
    if month < 12 and not c[month]:
        cost(month+1, S)
        return

    # 가지치기2: 전 달까지의 요금이 이미 최소를 넘었으면 더 이상 탐색x
    global min_cost
    if S > min_cost:
        return

    # 종료조건
    if month >= 12:
        min_cost = S
        return
    
    # 작은 가지치기3: 이번 달의 1일권 사용 요금이 1달권 사용 요금보다 적다면 1일권을 택, 아니라면 1달권을 택
    if p[0]*c[month] < p[1]:
        cost(month+1, S+p[0]*c[month])
    else:
        cost(month+1, S+p[1])
    cost(month+3, S+p[2])


for t in range(1, int(input())+1):
    p = list(map(int, input().split()))
    c = list(map(int, input().split()))
    min_cost = p[3]
    cost(0, 0)

    print('#%d %d' % (t, min_cost))
```

```python
# DP
# 전 달까지의 요금 + 이번 달의 1일권 * 날짜
# 전 달까지의 요금 + 1달권
# 3달 전까지의 요금 + 3달권(현재 달까지 3달권에 포함시키므로 2달 전에 3달권을 산 것이다.)
# 이 셋 중 최소의 값이 현재 달의 DP다.
# 처음 1, 2월만 3달 전의 값이 없으므로 if처리 해주면 된다.
# 마지막 11월, 12월에서 만약 3달권이 1달권이나 1일권보다 싼 케이스가 있을 경우를 대비해 전체를 15월까지 있는 것으로 보고 쭉 진행한다.
for t in range(1, int(input())+1):
    day, m_1, m_3, year = map(int, input().split())
    swim = [0] + list(map(int, input().split())) + [0, 0]
    swim_pay = [0]*15
    for month in range(1, 15):
        if month >= 3:
            swim_pay[month] = min(swim_pay[month-1]+day*swim[month], swim_pay[month-1]+m_1, swim_pay[month-3]+m_3)
        else:
            swim_pay[month] = min(swim_pay[month-1]+day*swim[month], swim_pay[month-1]+m_1)
    print("#%d %d" %(t, min(swim_pay[12], swim_pay[13], swim_pay[14], year)))
```

+ 요리사
  + 조합을 사용하는 문제로, 재귀가 이루어지기 때문에 어디서 이중 for문을 돌리느냐 등에 따라 실행시간에 많은 차이가 난다. 꼼꼼히 따져 어디에서 반복을 진행하는 것이 불필요한 반복을 없앨 수 있는 것인가를 잘 찾아야 한다.

```python
# N개의 재료 중에서 N//2개를 뽑는 함수
def combi(level, start):
    # 종료조건
    if level >= N//2:
        global min_dif
        result = get_taste(A, B)
        if result < min_dif:
            min_dif = result
        return

    for i in range(start, N-N//2+level+1):
        # 이렇게 remove append를 일일이 해주는 것이 나중에 A에서 없는 것을 for문을 돌며 찾아 B를 만드는 것보다 훨씬 실행시간이 짧다.
        A.remove(i)
        B.append(i)
        combi(level+1, i+1)
        A.append(i)
        B.remove(i)


def get_taste(A, B):
    taste_A, taste_B = 0, 0
    for i in range(N//2):
        for j in range(N//2):
            taste_A += arr[A[i]][A[j]]
            taste_B += arr[B[i]][B[j]]

    return abs(taste_A - taste_B)


for t in range(1, int(input())+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    min_dif = 987654321
    # A만 구성하고, B는 A에 없는 것으로 만들 것이다.
    A = list(range(N))
    B = []
    combi(0, 0)

    print('#%d %d' % (t, min_dif))
```

+ 느낀점 및 배운점
  + 현재의 나에게 난이도가 매우 높은 문제들이었다.
  + 특히, 이제는 얼마나 효율적으로 코드를 짜서 실행시간을 줄일 수 있는지가 관건이 되었다.
  + DFS의 경우 **가지치기**가 매우 중요하다. 오류가 생기지 않는 선에서 잘 쳐내야 한다.
  + 또한, 재귀를 사용하는 경우에는 재귀 안에서 반복문이 계속 실행되는 것을 염두에 두고 반복문의 위치를 밖으로 뺄 수 있다면 빼는 것이 코드를 효율적으로 만드는 가장 좋은 방법이다. 이를 잘 계산해보자.
  + 이제야 DFS를 활용하는 방법에 대해서 감이 오는 것 같다. 이전까지는 매우 막막했는데, 갑자기 길이 보이기 시작했다!



## 2021-03-15

+ 삼성 소프트웨어 역량 시험 A형 모의평가 대비 문제를 풀었다. SSAFY D4 난이도급 문제들이다.
+ **등산로 조성, 물놀이를 가자, 탈주범 검거**
+ **DFS, BFS** 등의 알고리즘 기법들을 사용해야 하는 문제들이었다.
+ 기본적인 DFS, BFS에서 벗어나 이제 기본 논리를 적극 활용하여 문제를 해결해야 하는 문제들이 나왔다.
+ 등산로 조성
  + 가지치기를 잘 해야하는 문제. 가지를 치지 않으면 런타임 에러가 발생한다.
  + 현재 등산로 개척을 아무리 해도 현재 제일 긴 등산로보다 길지 못하다고 판단될 때(유망성이 없을 때) 탐색을 종료하고 빠르게 돌아와야 한다.

+ 물놀이를 가자
  + **개인적으로 너무 힘들었던 문제**
  + 주어지는 입력량이 방대하기 때문에 런타임에러가 발생한다.
  + 입력 자체도 주어지는 입력(문자열)을 리스트로 변환해서 평소처럼 풀면 런타임 에러가 발생하기 때문에 문자열 그대로를 활용해 풀어야 한다.
  + 큐를 구현함에 있어, `pop(0)`연산은 맨 앞의 것을 빼고 그 이후의 것들을 하나씩 당겨오는 작업을 해야하므로 시간이 많이 든다.
  + 따라서, 나는 이를 `front`와 `rear`라는 두 변수를 사용하여 미리 큐를 고정된 길이를 갖는 리스트로 만들어서 해결하였다. (다른 팀원들은 deque 라이브러리를 import했다.)
+ 탈주범 검거
  + 이런 문제가 나는 잘맞는 것 같다.
  + 난이도가 높다고 하였으나, 나한테는 비교적 쉬웠고 푸는 재미가 있었다.
+ 느낀점 및 배운점
  + 시간을 넉넉히 갖고 제출도 무제한으로 할 수 있다면 당연히 풀 수 있는 문제들이다.
  + 하지만, 나는 아직까지는 제출을 여러 번하고 틀려가며 어디가 잘못되었는지를 디버깅하고를 꽤 많이 반복하는 문제가 있는 것 같다.
  + 실제 코딩 테스트에서는 제출 횟수에 제한을 둘 수도 있으므로 처음부터 빈틈없이 짜보려는 연습을 해야 할 것 같다.



## 2021-03-16

+ 삼성 소프트웨어 역량 시험 A형 모의평가 대비 문제를 풀었다. SSAFY D4 난이도급 문제들이다.
+ **홈 방범 서비스, 숫자 만들기, 무선 충전, 벽돌 깨기**
+ **DFS, BFS** 등의 알고리즘 기법들을 **혼합** 사용해야 하는 문제들이었다.
+ 이젠 한 문제에서 DFS와 BFS를 동시에 사용해야 하는 문제들이 나오기 시작했다.
+ 저번 A형 모의평가 대비 문제들보다 훨씬 높은 난이도의 문제들이었다.
  + 결국 원자 소멸 시뮬레이션이라는 정답률 16%의 극악 문제는 풀지 못하였다.
+ 문제 하나하나에 대해 정리하기보다는 문제의 정답은 다 맞았으므로, 느낀점 및 배운점으로 팁을 정리할 것이다.
+ 느낀점 및 배운점
  + 문제가 이제는 굉장히 길기 때문에, 문제를 잘 이해하고 주어진 조건과 요구사항을 정확히 파악하는 것이 중요하다. 요구사항을 잘못 파악해 시간 낭비를 조금 한 경험이 있다.
  + DFS와 BFS를 반전적으로 생각해보는 것도 좋다. 즉, A에서 B로 가는 경로를 찾고자 할 때, 역으로 B에서 A로 가는 경로를 찾는 것이 해답인 경우가 있다. 예) 물놀이를 가자
  + DFS와 BFS에 익숙해지긴 하였으나 응용만 풀다보니 기본이 가물가물해지는 느낌이다. 다시 한 번 복습하자.

+ **추가** - 최근 3월 11일, 3월 15일에 푼 문제들에 대해 IM 대비라고 잘못 적었다. IM보다 한 단계 위인 AD단계의 문제들이다. 이번 커밋으로 전부 수정한다.



## 2021-03-18

+ Difficulty 3의 정답율순 33번 ~ 41번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **다솔이의 월급 상자, 문자열의 거울상, 늘어지는 소리 만들기, 수의 새로운 연산, 외로운 문자**
+ 이번에도 역시 알고리즘이라는 느낌보다는 수학적으로 해법을 알아내는 데에 중점을 둔 문제인 것 같았다.
  + 하지만, 그러면서도 점점 알고리즘적 기법을 요하는 문제가 되어 가고 있다. 난이도가 확 높아졌다.
  + 외로운 문자와 같은 경우 스택을 이용하여 풀 수 있었다.
+ 수의 새로운 연산
  + 이 문제는 꽤 많이 어려웠다. 규칙을 찾기가 힘들어서 답을 찾아내기가 어려운 이런 문제가 생각보다 발목을 잡는 것 같다.

```python
# 첫 번째 대각선 (1, 1) = 1
# 두 번째 대각선 (1, 2), (2, 1) = 2, 3
# 세 번째 대각선 (1, 3), (2, 2), (3, 1) = 4, 5, 6
# ...
# n번째 대각선까지 대하여 for i in range(1, n+1)에서 (i, n+1-i)가 1씩 누적증가하는 규칙이다.
for t in range(1, int(input())+1):
    p, q = map(int, input().split())
    # p / q를 찾았는지의 플래그
    flag_p, flag_q = 0, 0
    # level번째 대각선
    level = 1
    num = 0
    while not flag_p or not flag_q:
        for i in range(1, level+1):
            num += 1
            if not flag_p and num == p:
                flag_p = 1
                p_x, p_y = i, level+1-i
            if not flag_q and num == q:
                flag_q = 1
                q_x, q_y = i, level+1-i

        level += 1

    o_x, o_y = p_x + q_x, p_y + q_y
    flag_o = 0
    o_level = 1
    result = 0
    while not flag_o:
        for i in range(1, o_level+1):
            result += 1
            if i == o_x and o_level+1-i == o_y:
                flag_o = 1
                break
        o_level += 1

    print('#%d %d' % (t, result))


# 2
# 승현님 코드
def find_xy(num):
    # _sum은 (_add, 1)의 값, _add는 몇 번째 대각선인지(내 코드의 level)
    _sum, _add = 0, 0
    while _sum < num:
        _add += 1
        _sum += _add
    dif = _sum - num # (_add, 1) 기준 dif만큼의 거리가 목표 x, y위치다.

    return (_add - dif, 1 + dif)


for t in range(1, int(input())+1):
    a, b = map(int, input().split())
    a_loc, b_loc = find_xy(a), find_xy(b)
    c_loc = (a_loc[0]+b_loc[0], a_loc[1] + b_loc[1])
    dif = c_loc[1] - 1
    cross = (c_loc[0] + dif)*(c_loc[0] + dif + 1)//2
    print("#%d %d" %(t, cross-dif))
```

+ 느낀점 및 배운점

  + 지난 번 SWEA 문제 풀이 때 느낀점으로 '하지만 이러한 것들이 기존의 난이도가 높았던 알고리즘 문제에 접합되어 섞여 나온다면 굉장히 고난이도의 문제로 변할 수 있을 것 같기 때문에, 지금 난이도가 낮다 하더라고 쉽게 넘기지 않고 수학적인 풀이들을 익혀야겠다는 생각이 들었다.'라고 적었었다.
  + 여실히 걱정거리가 이루어진 회차였다. 수학적 풀이를 요하는 문제에 알고리즘을 사용해서 그 풀이를 해야하는 문제들이 나오자 새로운 유형에 꽤나 당황을 했다.

  + 당황을 했다는 것만큼, 매우 중요한 경험이었다.



## 2021-03-23

+ Difficulty 3의 정답율순 42번 ~ 47번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **태혁이의 사랑은 타이밍, N-Queen, 건초더미, 새샘이의 7-3-5게임, 100만 이하의 모든 소수**
+ **날짜/시간 계산, DFS, 조합, 소수 공식** 등의 알고리즘 기법들을 사용해야 하는 문제들이었다.
+ N-Queen
  + DFS의 매우 유명한 문제라고 한다. 나는 처음 풀어보았는데, 델타 검색을 이용하지 않고 DFS를 이용한 순열의 개념을 이용하여 풀었다.

```python
# N*N 보드에 N개의 퀸을 서로 다른 두 퀸이 공격하지 못하게 놓는 경우의 수는 몇가지가 있을까?
# N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.


# level은 말의 개수이자 각 행
def DFS(level):
    # 모든 말을 다 채우면 cnt += 1
    if level >= N:
        global cnt
        cnt += 1
        return
    # 각 행에서 0~N-1번째 열 중에 선택
    for i in range(N):
        # 만약 i번째 열이 아직 선택되지 않았다면 놓을 수 있는지 체크(대각선 공격 영역에 들어가는지 확인하는 것이다.)
        if not col[i]:
            # 퀸이 놓여져 있는 좌표를 하나씩 가져와서
            for r, c in queen_list:
                # 현재의 행과 기존에 퀸이 놓여진 행의 거리와, 현재의 행이 선택한 열과 기존에 퀸이 놓여진 열의 거리가 같다면 대각선에 있는 것이다.
                # ex) 현재의 행과 열이 (2, 2)고, 기존의 퀸이 놓여진 행과 열이 (1, 1)이라면 행 간의 거리와 열 간의 거리가 같고, 대각선에 있는 것이다.
                if abs(level - r) == abs(i - c):
                    break
            else:
                # 공격 영역에 없다면 열을 차지하고, 퀸 리스트에 추가하고, 다음 레벨 실행
                col[i] = 1
                queen_list.append((level, i))
                DFS(level+1)
                # 탐색이 끝나면 열을 되돌려주고, 퀸 리스트에서도 제거
                col[i] = 0
                queen_list.pop()


drc = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, 1], [1, 1], [1, -1], [-1, -1]]
for t in range(1, int(input())+1):
    N = int(input())
    # N줄의 열, 각 행에서 열을 선택하는 식으로 할 것이다. (이러면 퀸의 가로 세로 공격 영역에 대한 탐색은 알아서 이루어진다.)
    col = [0]*N
    # 행이 열을 선택하면, 그 위치가 퀸의 위치이고 이를 저장할 것이다.
    queen_list = []
    cnt = 0
    DFS(0)
    print('#%d %d' % (t, cnt))
```

+ 10만 이하의 모든 소수
  + 나는 '에리토스테네스의 체'라는 방법을 사용하여 풀이하였다.
    + 찾고자 하는 자연수를 배열로 나열하여 그 수중에 소수의 배수들을 전부 지워나가며 남은 소수를 찾는 방식이다.
  + 이외의 방법으로는, 매 수마다 그 수보다 작은 소수들로 나눠서 나뉘어 떨어지지 않는지를 찾으면 된다. 그러다가 **나누는 수가 해당 수의 루트한 것보다 커지면 소수가 된다**.
    + 예) 17의 경우 그보다 작은 소수인 2, 3, 5, 7, 9, 11, 13으로 순서대로 나누다가 17의 루트값인 약 4.x를 나누는 수가 넘으면 소수로 분류한다. 3에서 나누어 떨어지지 않고 그 다음 소수는 5로 4.x보다 크니까 17은 소수다.

```python
# 1
# 에리토스테네스의 체
# 현재의 수를 기준으로 10**6까지 사이에 있는 모든 배수를 다 지우면서 진행한다.
num = [0, 0] + [1] * (10**6 - 1)
for i in range(2, 10**6+1):
    if num[i]:
        print(i, end=' ')
        for j in range(i*2, 10**6+1, i):
            num[j] = 0


# 2
# 약수를 확인할 때는 본인의 루트 값 까지만 알면 된다.
def isprime(x):
    for prime in prime_list:
        # 루트를 넘어서면 나눠지지 않는 것이다.
        if prime**2 > x:
            break
        if x % prime == 0:
            return False
    return True


prime_list = [2]
for n in range(3, 1000001):
    if isprime(n):
        prime_list.append(n)
print(*prime_list)
```

+ 느낀점 및 배운점

  + N-Queen문제와 10만 이하의 소수 구하기 문제가 어려웠다. N-Queen의 경우 그래도 순열로 풀면 된다는 것을 잘 캐치해서 쉽게 풀 수 있었다. 10만 이하의 소수 구하기의 경우, **모든 수의 약수를 구할 때는 그 수의 루트 값보다 작거나 같은 수까지만 나눠보면서 짝을 만들면 된다는 것을 알았다.**

  + 날짜 및 시간 계산의 경우에는 그냥 **문제에서 주어지는 기준점을 0으로 만드는 것을 택하자.**
    + 예) 11월 11일 11시 11분에서 일, 시, 분을 계산해야하는 경우, 11월 11일 0시 0분으로 맞춰서 나중에 뺀 시간만큼 조정을 하자



## 2021-03-25

+ Difficulty 3의 정답율순 46번, 49번, 50번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **신뢰, 두 수의 덧셈, 전봇대**
+ 머릿 속에서 답을 구하기 위해 어떤 방식을 찾아내야 할지를 계속 생각해야 하는 문제들이었다.
  + 알고리즘 기법이 사용되지는 않았으나, 정말 심플하게 사고력을 체크하는 느낌이었다.
  + 문제가 좋다고 느껴졌다.
+ 신뢰

```python
for t in range(1, int(input())+1):
    data = list(input().split())
    pos_B, pos_O = 1, 1
    # 이번 시행에서 각 로봇이 사용한 시간
    time_B, time_O = 0, 0
    # 각 로봇이 상대 로봇이 움직이는 동안 같이 움직이며 세이브 한 시간
    save_B, save_O = 0, 0
    result = 0
    for i in range(1, len(data), 2):
        robot = data[i]
        button = int(data[i+1])
        # 완전 중복인데 함수화하면 짧아질 듯?
        if robot == 'B':
            # 버튼에 도달하기까지 필요한 시간 = 버튼까지의 거리 - 반대쪽 로봇이 움직인 동안 같이 움직여 세이브한 시간
            need_time = abs(button - pos_B) - save_B
            # 버튼을 도달하기까지 필요한 시간보다 세이브한 시간이 많으면 누르는 시간 1초만 계산
            time_B = need_time + 1 if need_time > 0 else 1
            result += time_B
            # 사용한 시간만큼 반대쪽 로봇의 시간이 세이브된다.
            save_O += time_B
            # 시행이 끝났으므로 '사용한 시간'은 0으로 초기화, 위치는 버튼으로
            time_O, pos_B = 0, button
            # 반대쪽 로봇이 쌓아준 세이브 타임을 썼으므로 0으로 초기화
            save_B = 0
        else:
            need_time = abs(button - pos_O) - save_O
            time_O = need_time + 1 if need_time > 0 else 1
            result += time_O
            save_B += time_O
            time_B, pos_O = 0, button
            save_O = 0

    print('#%d %d' % (t, result))
```

```python
# 가독성 없이 짧게 짠 코드
# 리스트의 인덱스 접근의 반복으로 시간은 아주 조금 더 걸린다.
for t in range(1, int(input())+1):
    data, B, O, result = list(input().split()), [1, 0, 0], [1, 0, 0], 0
    for i in range(1, len(data), 2):
        robot, oppose = (B, O) if data[i] == 'B' else (O, B)
        button = int(data[i+1])
        need_time = abs(button - robot[0]) - robot[2]
        robot[1] = need_time + 1 if need_time > 0 else 1
        result, oppose[2], robot[0], robot[2] = result + robot[1], oppose[2] + robot[1], button, 0

    print('#%d %d' % (t, result))
```

+ 느낀점 및 배운점
  + 사실 신뢰 문제는 알고리즘을 배우기 시작한 초기에 풀었던 문제였다. 그때는 자그마치 코드의 길이가 3000자였고, 2시간을 넘게 풀었던 것으로 기억한다.
  + 확실히 이제는 문제를 보면 어떻게 풀어나가야 할지, 무슨 변수가 필요한지가 머리 속에 조금씩 그려지는 것 같다. 이번 신뢰를 봤을 때는 예전에 한 번 풀어봐서인 것도 있겠지만, 바로 무엇이 필요한지 캐치할 수 있었다. 약간 머리 속에서 그려지는 문제의 모습을 **추상화**하는 것에 익숙해진 것 같다.
  + 전깃줄 문제도 신박한 문제였다. 알고리즘은 전혀 필요하지 않고 사고력을 요하는 문제였다. 깔끔한 문제라고 생각한다.



## 2021-03-30

+ 백준 특강 문제들을 풀었다.
+ **제곱근, 소풍, 요세푸스 문제 3, 골드바흐 파티션**
+ 정말 한 문제도 풀지 못했다. 백준에서 각각 난이도 브론즈1, 실버2, 골드1, 플레티넘의 난이도를 하는 문제들이라고 한다.
+ 약간 알고리즘에서의 좌절감을 맛봤으나, 이번 주말에 반드시 다시 풀어내고 말 것이다. 주말에 다시 리뷰하겠다.



## 2021-04-01

+ Difficulty 3의 정답율순 51~56번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **상호의 배틀필드, 화섭이의 정수 나열, 부분 수열의 합, 정삼각형 분할 놀이, 파도반 수열**
+ 이번 5개의 문제 구성이 매우 좋았다. 각각 다른 알고리즘을 사용해야 했다.
+ **델타를 활용한 2차원 배열, 입력값 자유롭게 받기, DFS 조합, 수학적 규칙찾기, DP**를 사용해 풀어야 하는 문제들이었다.
+ 상호의 배틀필드같은 델타를 활용한 2차원 배열 문제는 **index**의 범위를 정말 잘잡아야 한다.
  + 인덱스가 자꾸 벗어나서 런타임 에러가 계속 발생했었다.
  + SWEA의 런타임 에러는 대부분 인덱스 에러이다.
+ 입력값이 불규칙적으로 자유롭게 주어지는 경우에는 **각 줄을 입력받아 공백을 제거한 상태에서 리스트에 담는 것**으로 모든 데이터를 안전하게 리스트에 입력받을 수 있다.
+ 부분 수열의 합은 DFS 조합을 응용하는 문제였는데, 어렵지 않았다.
+ 파도반 수열이 처음 DP로 푼 문제였다. 아직 DP를 배우지 않았는데, 앞으로 많이 조우할 것 같다.
+ 느낀점 및 배운점
  + 이번에도 문제들이 쉽지 않았다. 특히 지금은 django를 배우고 있어서 알고리즘이 점점 덜 익숙해지는 느낌이다.
  + 다음 주부터 다시 알고리즘 기간으로 들어가기 때문에 이번에 실력을 확 올려볼 것이다.



## 2021-04-06

+ Difficulty 3의 정답율순 57~62번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **성공적인 공연 기획, 항구에 들어오는 배, 몬스터 사냥, 최장 증가 부분수열(LIS)**
+ 이번 4개의 문제 구성도 매우 좋았다. 컴퓨팅사고력을 요하는 문제들이었다.
+ **카운트 리스트 활용, 소수 구하기, 등차수열의 합, LIS**를 사용해 풀어야 하는 문제들이었다.
+ 최장 증가 부분수열 문제는 **나만 풀었다!**
  + LIS라는 개념을 알고 있어야 해결이 간편한 문제였다.
    + 이외의 방법으로 풀면 시간 초과가 발생하는 듯 했다.
  + 이번 LIS 문제는 가장 기본적인 LIS 그 자체의 문제였다. 어렵지 않게 풀 수 있었다.

```python
for t in range(1, int(input())+1):
    N = int(input())
    num = list(map(int, input().split()))
    # 각 차례에서의 증가 수열 길이를 담을 카운트 리스트
    cnt_list = [1]*N
    # 두 번째 숫자부터
    for i in range(1, N):
        max_cnt = 0
        # 자신의 이전 숫자들에 대하여, 이전 숫자가 자신보다 작으면서 증가 수열 길이가 가장 길다면
        # 자신의 증가 수열 길이는 해당 숫자의 증가 수열 길이 + 1이다.
        # 즉, 현재 숫자 i의 이전 숫자이면서 i보다 작은 숫자들 중 j의 cnt_list 값이 다른 숫자들의 cnt_list 값보다 클 경우, i의 cnt_list 값은 j의 cnt_list 값 + 1
        for j in range(i-1, -1, -1):
            if num[i] >= num[j] and cnt_list[j] > max_cnt:
                max_cnt = cnt_list[j]
            cnt_list[i] = max_cnt + 1
            # 만약 max_cnt보다 j가 더 작다면 처음부터 j번까지 전부 증가 수열이라고 해도 길이가 max_cnt보다 짧으므로 break
            if j < max_cnt:
                break

    print('#%d %d' % (t, max(cnt_list)))
```

+ 느낀점 및 배운점
  + 쉬운 문제들은 아니었다. 하지만, 이번 회차의 4 문제들을 전부 풀 수 있었고, 대부분의 스터디원들이 1~2개 정도 푼 것을 생각하면 내가 많이 발전한 것 같다.
  + 더욱이, 내가 스터디원들에게 내가 아는 것을 알려주며 도와줄 수 있다는 것이 좋았다.
  + 컴퓨팅 사고력에 관한 수업이 싸피에서도 곧 진행되는데, 많은 유형들을 익혀야겠다고 생각했다.



## 2021-04-06(2)

+ 싸피 Day17의 알고리즘 문제들을 복습하였다.
+ **트리의 전위순회, 중위순회, 이진탐색트리 생성, 이진탐색트리 연산연습**
+ **트리, 이진트리**에 관한 문제들이었다.
+ DFS, BFS를 넘어 트리라는 새로운 주제로 들어서서 싸피 알고리즘 학습 내용을 다시 리뷰하기 시작했다.
+ 트리의 순회

```python
def preorder_travers(node):
    way.append(node) # 전위순회
    if len(tree[node]) >= 3:
        preorder_travers(tree[node][2])
    # way.append(node) 중위순회
    if len(tree[node]) == 4:
        preorder_travers(tree[node][3])
    # way.append(node) 후위순회


V = int(input()) # 노드 개수
E = list(map(int, input().split())) # 간선 정보
# 확장 문제에서의 활용을 위해 tree가 담는 정보는 현재 노드, 부모 노드, 왼쪽 자식 노드, 오른쪽 자식 노드
tree = [[i, 0] for i in range(V+1)]
for i in range(0, len(E), 2):
    # 자식
    tree[E[i]].append(E[i+1])
    # 부모
    tree[E[i+1]][1] = E[i]

root = 0
for i in range(1, V+1):
    if tree[i][1] == 0:
        root = i

way = []
preorder_travers(root)
print('-'.join(map(str, way)))
```

+ 이진탐색트리
  + 코드가 굉장히 길고 내용이 어렵다. README에 전부 리뷰하기에는 양이 많으므로 코드로만 남겨놓겠다.

+ 느낀점 및 배운점
  + 기본적인 트리에 대한 내용을 배웠고, 이진트리에서 내가 원하는 곳으로 이동하는 방법들을 배웠다.
  + 부모 노드와 자식 노드를 자유롭게 왔다갔다 할 수 있도록 연습해야겠다.



## 2021-04-06(3)

+ 싸피 Day18의 알고리즘 문제들을 복습하였다.

+ **서브트리, 이진탐색, 이진 힙, 노드의 합, 사칙연산**

+ **이진트리**에 관한 문제들이었다.

+ 이진트리는 각 노드가 가지는 정보가 **왼쪽 자식 노드, 오른쪽 자식 노드, 자신, 부모 노드**라는 것만 인지하면 생각보다 많이 어렵지는 않았다.

  + 또한 이를 활용해서 코드를 굉장히 간단하게 짤 수 있었고, 필요한 정보만을 내가 취하면 되기 때문에 동기들에 비해 내 코드가 **월등히 짧았다.**
  + 덕분에 수업 중에도 참신한 아이디어로 자주 언급이 되었다.

+ **완전 이진트리**에서 각 노드가 가지는 값만을 사용하여 해결해도 되는 문제라면, 복잡하게 노드에 자식 노드와 부모 노드의 정보를 담을 필요가 없다.

  + **완전 이진트리의 특성인 부모 노드와 자식 노드의 관계**를 사용한다.

    + 부모 노드의 번호가 N이라면 왼쪽 자식 노드는 2*N, 오른쪽 자식 노드는 2\*N+1이다.

  + 이를 통해 리프 노드부터 시작해서 문제를 풀어야 하는 경우, 노드의 값만 취하면 되는 경우와 같을 때에 매우 간단하게 해결할 수 있다.

  + 예시로 완전 이진 트리의 리프 노드에 자연수들이 저장되어 있고, 리프 노드를 제외한 노드에는 자식 노드에 저장된 값의 합이 들어있을 때 L번 노드의 값을 구하는 코드는 아래와 같이 간단히 해결할 수 있다.

  + ```python
    for t in range(1, int(input())+1):
        N, M, L = map(int, input().split())
        # 일단 모든 트리의 노드의 값은 0으로 초기화한다.
        tree = [0] * (N+1)
        for _ in range(M):
            # 리프 노드 번호와 값을 입력받는다.
            node, v = map(int, input().split())
            tree[node] = v
    
        for i in range(N, 0, -1):
            # 부모 노드의 값에 자식 노드의 값을 더한다.
            tree[i//2] += tree[i]
    
        print('#%d %d' % (t, tree[L]))
    ```

+ 느낀점 및 배운점
  + 이진 트리를 배우며 링크드 리스트라는 개념도 함께 접했는데, 우리는 링크드 리스트라는 것을 구현하지는 않았다. `Class`를 사용하여 생성하는 것 같으므로, 연습해봐야 할 것 같다.
  + 사실 파이썬에서는 리스트를 사용해서 left와 right를 전부 편하게 구현할 수 있기 때문인 것 같다.
  + 트리의 구조에서 노드에 접근하는 방법이 다양한만큼, 동기들의 답안이 가지각색이었다. 많은 코드를 앞으로도 계속 해석하고 뜯어봐야겠다.
    + 코드가 다양할수록 더욱 더 승부욕이 붙는다. 이번 트리에서는 내 코드가 가장 짧고 효율적이고 좋았다!



## 2021-04-08

+ 싸피 Day19의 알고리즘 문제들을 복습하였다.
+ **Merge Sort**
+ **합병정렬**에 대해 배웠다.
+ 합병정렬은 주어진 배열을 각 하나가 될 때까지 반으로 자르다가 하나가 되면 다시 역으로 돌아오면서 합병을 하며 정렬을 하는 알고리즘이다.
  + 합병정렬의 메리트는 시간복잡도가 언제나 **O(nlogn)**이라는 것이다.
    + 반씩 잘라 내려가기 때문에 내려가는 깊이 logn이고, 한 deapth마다 진행하는 정렬의 방식이 2개를 합병하는 과정에서 한 쪽의 길이만큼 비교가 이루어지므로 최대 n의 비교가 일어난다고 가정한다.

```python
def merge_sort(arr):
    # 하나가 남을 때까지 쪼개놨으면 자기 자신 리턴
    if len(arr) == 1:
        return arr
    # 가운데 정하기
    mid = len(arr) // 2
    # 쪼개서 왼쪽
    a_arr = merge_sort(arr[:mid])
    # 쪼개서 오른쪽
    b_arr = merge_sort(arr[mid:])
    # 아래에서 넘어온 두 조각을 정렬
    temp = [] # a_arr, b_arr을 정렬하며 합쳐서 담을 temp
    ai = bi = 0
    # 한쪽의 조각을 temp에 다 담을 때까지
    while ai < len(a_arr) and bi < len(b_arr):
        if a_arr[ai] < b_arr[bi]:
            temp.append(a_arr[ai])
            ai += 1
        else:
            temp.append(b_arr[bi])
            bi += 1
    # 담지 못한 나머지 조각을 전부 temp에 붓기
    if ai == len(a_arr):
        temp.extend(b_arr[bi:])
    else:
        temp.extend(a_arr[ai:])

    return(temp)


a = [5, 1, 9, 6, 8, 4, 2, 3]
print(merge_sort(a))
```

+ 느낀점 및 배운점
  + 사실 예전에 정렬에 대해 이것저것 검색을 해보다가 합병정렬에 대해서 읽어 봤었다.
  + 그때는 버블정렬, 카운팅정렬, 선택정렬만 알고 있었던 상태라 이해가 잘 되지 않았었다.
    + 하지만, 트리를 배우고 나서 다시 새롭게 보니 이해가 아주 잘되었다.
    + 특히, 시간복잡도가 이해가 안되었는데 대략 이해가 가는 것 같다.
  + 합병정렬은 다른 정렬들이 최악의 경우에 훨씬 큰 시간복잡도를 가지게 될 수도 있는 불안성을 가지지 않는다는 장점이 있다. 합병정렬은 최악의 상황에도 O(nlogn)이기 때문에 앞으로 정렬이 있을 때 활용해보면 좋을 것 같다.



## 2021-04-08 (2)

+ 싸피 Day20의 알고리즘 문제들을 복습하였다.
+ **트리 시각화**
+ **트리를 그래프로 출력**하는 알고리즘을 짜보았다.
+ 컴퓨팅 사고력을 배우면서 트리의 구조를 그래프로 출력하는 코드를 짜보았다. 
  + 코딩 상 한 줄씩 출력해야 하기 때문에 DFS의 느낌으로 구동이 되는 것 같다.

```python
def draw_tree(level, p, c):
    # 루트 노드
    if level == 0:
        print('[%s]' % c.zfill(3), end='')
        for node in tree[c]:
            draw_tree(level+1, c, node)
        return
	# 자식 노드가 1개 이상이라면 폴더 구조같이 잇기
    if len(tree[p]) > 1:
        if c == tree[p][0]:
            print('--+--[%s]' % c.zfill(3), end='')
        elif c == tree[p][-1]:
            print((2*level-1) * '     ', end='')
            print('  L--[%s]' % c.zfill(3), end='')
        else:
            print((2*level-1) * '     ', end='')
            print('  +--[%s]' % c.zfill(3), end='')
    # 자식 노드가 1개라면 일직선으로만 잇기
    elif len(tree[p]) == 1:
        print('-----[%s]' % c.zfill(3), end='')
	# 자식 노드가 없다면(리프 노드라면) 그래프를 끝내고 다음 줄 출력하기
    if not tree.get(c):
        print()
        return
    for node in tree[c]:
        draw_tree(level+1, c, node)


N = int(input())
tree = {}
e = list(input().split())
for i in range(N-1):
    tree[e[2*i]] = tree.get(e[2*i], []) + [e[2*i+1]]

draw_tree(0, 0, e[0])
```

```pseudocode
# 입력
10
30 54 30 2 30 45 54 1 45 123 45 7 1 3 123 6 123 9 123 11 45 100


# 결과
[030]--+--[054]-----[001]-----[003]
       +--[002]
       L--[045]--+--[123]--+--[006]
                           L--[009]
                 L--[007]
```

+ 느낀점 및 배운점
  + 트리라는 구조를 실제로 출력해봤는데, 굉장히 재밌었다.
  + print문의 인간승리인 것 같다. 사실 보기에 좋은 것 같지 않아서 다른 사람들의 코드도 있다면 참고해봐야 할 것 같다.
  + 그래도 잘 나오는 것 보니 만족한다!

<<<<<<< HEAD


## 2021-04-08

+ Difficulty 3의 정답율순 63~67번 문제를 풀었다. SSAFY과정 중 완료한 문제들은 제외했다.
+ **새샘이의 세 소수, 이진수 표현, 최대 상금, 세상의 모든 팰린드롬**
+ **소수, 이진수의 특성, 선택 정렬, 회문**의 알고리즘을 사용해 풀어야 하는 문제들이었다.
+ 최대상금이 정말 너무 어려웠다.
  + 문제가 되는 케이스들이 많기 때문에 전부 분기처리를 해주어야 한다.
    + 심지어 그 분기들은 각자 안에서 정렬 및 반복문을 해야하는 분기들이었다.
+ 최대상금 코드

```python
# 숫자와 변경횟수가 주어졌을 때, 변경횟수만큼 숫자 자리를 바꿔 최대 숫자를 만들어라
# 제자리 변경은 불가능하며, 주어진 횟수가 남아있으면 무조건 변경해야한다.


for t in range(1, int(input())+1):
    num, cnt = input().split()
    num, cnt = list(map(int, num)), int(cnt)
    # max값들끼리의 숫자가 중복될 때 문제가 생긴다.
    # 예를 들어, 선택 정렬을 사용할 것이기 때문에 3288을 두 번 교환하면 8823이 된다. 내가 원하는 것은 8832이다.
    # 따라서, max값과 자리를 바꿔 이동하게 된 숫자들은 그들끼리 다시 정렬을 해줘야 한다.
    # 그러면서도 같은 max값과 바뀐 숫자들끼리 내에서 정렬을 해줘야 한다.
    # 예를 들어, 32417788이라면 3과 2는 같은 8과 바뀌니 둘이 정렬하고 4와 1은 같은 7로 바뀌니 둘이 정렬해야 한다. 88774132가 되도록.
    # 그러므로 카운트 리스트와 비슷하게 인덱스를 이용하여 각 max값에 해당하는 곳에 자리를 바꾼 수들을 저장한다.
    changed_list = [[] for _ in range(10)]
    for i in range(0, len(num)-1):
        max_i = i
        for j in range(i+1, len(num)):
            if num[j] >= num[max_i]:
                max_i = j

        if num[max_i] != num[i]:
            cnt -= 1
            changed_list[num[max_i]].append(max_i)
            num[i], num[max_i] = num[max_i], num[i]
            # 최대값이 있던 자리에 밀려난 숫자가 온 것이므로 최대값이 있던 자리를 changed_list에 append

        if cnt == 0:
            break
    # 횟수가 남아있다면 그것은 이미 내림차순으로 정렬이 된 상태를 의미한다.
    if cnt:
        # 만약 중간에 중복되는 자리가 있으면 그 둘을 서로 계속 swap할 것이므로 그냥 실행 안한거나 같다. ex) 7770
        if len(num) != len(set(num)):
            pass
        # cnt가 다할 때까지 1의 자리와 10의 자리만 계속 swap
        else:
            while cnt:
                num[-1], num[-2] = num[-2], num[-1]
                cnt -= 1
    # 내림차순 정렬이 안되어 있는 상태라면 max값과 자리를 바꾼 수들끼리의 정렬을 실행
    else:
        # 카운트 리스트 내의 각 리스트에 대하여(각 max값에 대해 자리를 바꾼 수들의 리스트에 대하여)
        for c_list in changed_list:
            # 자리를 바꾼 수가 2개 이상이라면
            if len(c_list) > 1:
                # 총 바꿀 횟수는 자리를 바꾼 수들의 개수 - 1번. 예) 3, 2, 1이 있다면 적어도 2번은 선택 정렬해야 정렬이 된다.
                change_cnt = len(c_list) - 1
                # 선택 정렬을 하기 위해서 일단 수들을 오름차순 정렬한다.
                c_list.sort()
                # 인덱스를 이용하여 수들끼리의 정렬을 구현한다.
                for i in range(len(c_list) - 1):
                    max_i = c_list[i]
                    for j in range(i + 1, len(c_list)):
                        if num[c_list[j]] >= num[max_i]:
                            max_i = c_list[j]
                    num[c_list[i]], num[max_i] = num[max_i], num[c_list[i]]
                    change_cnt -= 1
                    if change_cnt == 0:
                        break

    result = 0
    won = 1
    for i in range(len(num)-1, -1, -1):
        result += num[i]*won
        won *= 10
```

+ 느낀점 및 배운점
  + 다른 문제들은 별 문제가 없었고, 이번엔 최대 상금만이 커다란 고난이었다.
    + 심지어 어려운 알고리즘 기법을 필요로 하는 것도 아니었고 단지 복잡하게 모든 경우에 해야 하는 작업들을 생각하는 능력이 필요한 문제였다.
  + 답을 써놓고도 한참을 틀리고 고쳐서 작성한 코드이기 때문에 가독성도 떨어지고 타인이 봤을 때 이해하기가 쉽지 않을 것 같다는 생각이 든다. 
    + 그래도 코드를 따져보면 빈틈 없이 작업이 수행되기는 한다..!
  + 사실 알고리즘이 점점 어려워지고 CT까지 익히려다 보니 몸이 많이 지치는 것 같다.
    + 힘내자!!