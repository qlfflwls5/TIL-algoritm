# 재미있는 오셀로 게임
# 오셀로라는 게임은 흑돌과 백돌을 가진 사람이 번갈아가며 보드에 돌을 놓아서 최종적으로 보드에 자신의 돌이 많은 사람이 이기는 게임이다.
# 보드는 4x4, 6x6, 8x8(가로, 세로 길이) 크기를 사용한다. 6x6 보드에서 게임을 할 때, 처음에 플레이어는 다음과 같이 돌을 놓고 시작한다(B : 흑돌, W : 백돌).
# 4x4, 8x8 보드에서도 동일하게 정가운데에 아래와 같이 배치하고 시작한다.

# W B
# B W

# 그리고 흑, 백이 번갈아가며 돌을 놓는다.
# 처음엔 흑부터 시작하는데 이 때 흑이 돌을 놓을 수 있는 곳은 다음과 같이 4군데이다.

#   O
# O W B
#   B W O
#     O

# 플레이어는 빈공간에 돌을 놓을 수 있다.
# 단, 자신이 놓을 돌과 자신의 돌 사이에 상대편의 돌이 있을 경우에만 그 곳에 돌을 놓을 수 있고, 그 때의 상대편의 돌은 자신의 돌로 만들 수 있다.
# (여기에서 "사이"란 가로/세로/대각선을 의미한다.)
# (2, 3) 위치에 흑돌을 놓은 후의 보드는 다음과 같다.

# B B B
#   B W

# 이런 식으로 번갈아가며 흑, 백 플레이어가 돌을 놓는다.
# 만약 돌을 놓을 곳이 없다면 상대편 플레이어가 다시 돌을 놓는다.
# 보드에 빈 곳이 없거나 양 플레이어 모두 돌을 놓을 곳이 없으면 게임이 끝나고 그 때 보드에 있는 돌의 개수가 많은 플레이어가 승리하게 된다.


# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스의 첫 번째 줄에는 보드의 한 변의 길이 N과 플레이어가 돌을 놓는 횟수 M이 주어진다. N은 4, 6, 8 중 하나이다.
# 그 다음 M줄에는 돌을 놓을 위치와 돌의 색이 주어진다.
# 돌의 색이 1이면 흑돌, 2이면 백돌이다.
# 만약 3 2 1이 입력된다면 (3, 2) 위치에 흑돌을 놓는 것을 의미한다.
# 돌을 놓을 수 없는 곳은 입력으로 주어지지 않는다.


#  [출력]
# 각 테스트 케이스마다 게임이 끝난 후 보드 위의 흑돌, 백돌의 개수를 출력한다.
# 흑돌이 30개, 백돌이 34인 경우 30 34를 출력한다.


def put(r, c, player):
    if player == 1:
        enemy = 2
    else:
        enemy = 1

    arr[r][c] = player
    cnt[player] += 1
    for dr, dc in drc:
        # 델타 검색이 가능한 범위에서
        if -1 < r+dr < N and -1 < c+dc < N:
            # 내 돌 주변에 적 돌이 있다면
            if arr[r+dr][c+dc] == enemy:
                # 적 돌의 위치를 스택에 추가하고
                stack = [[r+dr, c+dc]]
                # 그 적 돌을 기준으로 같은 방향으로 델타 검색 진행
                nr, nc = r+2*dr, c+2*dc
                while -1 < nr < N and -1 < nc < N:
                    # 쭉 적이 나오다가 내 돌이 나오면 그 사이 적 돌을 전부 내 것으로
                    if arr[nr][nc] == player:
                        for nr, nc in stack:
                            arr[nr][nc] = player
                        # 스택의 길이만큼 player의 개수에 추가, enemy의 개수에서 감소
                        cnt[player] += len(stack)
                        cnt[enemy] -= len(stack)
                        break
                    # 내 돌이 아니고 상대 돌이라면 stack에 넣고 계속 진행
                    elif arr[nr][nc] == enemy:
                        stack.append([nr, nc])
                        nr += dr
                        nc += dc
                    # 빈 공간이 나오면 내 돌이 감싸고 있는 것이 아니므로 break
                    else:
                        break
                        

# 위부터 시계방향 델타
drc = [[-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1]]
T = int(input())
for t in range(1, T+1):
    N, M = map(int, input().split())
    arr = [[0]*N for _ in range(N)]
    # 처음 시작 만들기
    arr[(N-2)//2][(N-2)//2:(N-2)//2+2], arr[(N-2)//2+1][(N-2)//2:(N-2)//2+2] = [2, 1], [1, 2]
    # 흑돌과 백돌의 개수. 2개씩 시작
    cnt = [0, 2, 2]
    for _ in range(M):
        c, r, player = map(int, input().split())
        # 문제에서 주어지는 좌표를 실제 arr에 적용하기 위해서 조정 필요
        put(r-1, c-1, player)

    print('#%d %d %d' % (t, cnt[1], cnt[2]))