# 무인도 탈출
# 배를 타고 여행중이던 나삼성씨가 태풍을 만났다.
# 배는 난파되었고, 나삼성씨는 구명보트를 이용하여 가까스로 탈출에 성공 할 수 있었지만,
# 표류 끝에 무인도에 갖히게 되었다.
# 무인도에 갖힌 나삼성씨는, 인근 해상을 지나가는 비행기를 향해 SOS 신호를 보내려고 한다.
# 구명보트를 탈출할 당시 챙겨온 N 개의 직육면체 모양 상자들을
# 아래 [그림 1] 과 같이 탑처럼 쌓아 올려서 눈에 잘 보이게 하려고 한다.

# 상자를 쌓는 규칙은 다음과 같다.

# 1. 각각의 상자는 가로, 세로, 높이 축을 기준으로 90 도씩 회전시켜서 쌓을 수 있다.
# 2. N 개의 상자를 쌓는 순서에는 별다른 제약이 없으며, 모든 상자를 다 사용하지 않아도 된다.
# 3. 모든 상자의 밑면은, 바로 아래 쌓여진 상자의 윗면을 벗어나선 안된다.

# 입력으로 N 개의 상자들의 가로, 세로, 높이의 길이가 각각 주어질 때,
# 쌓을 수 있는 최대 높이를 계산하는 프로그램을 작성하라.


# [제약 조건]
# 1. 상자 갯수 N 은 2 이상 20 이하의 정수이다. (2 ≤ N ≤ 20)
# 2. 상자의 한 변 길이는 1 이상 10,000 이하이다.


# [입력]
# 입력은 첫 줄에 총 테스트 케이스의 개수 T 가 온다.
# 다음 줄부터 각 테스트 케이스가 주어진다.
# 각 테스트 케이스의 첫 줄에는 상자들의 개수 N 이 주어지고,
# 두 번째 줄 부터는 각각의 상자들의 가로, 세로, 높이 길이가 나열된다.


# [출력]
# 테스트 케이스 t 에 대한 결과는 “#t” 을 찍고, 한 칸 띄고, 정답을 출력한다.
# ( t 는 테스트 케이스의 번호를 의미하며 1 부터 시작한다. )
# 상자를 쌓아서 만들 수 있는 최대 높이를 정답으로 출력한다.


# DFS로 풀면 시간초과가 난다. DP를 이용해서 해결한다.
for t in range(1, int(input())+1):
    N = int(input())
    boxes = []
    for i in range(N):
        w, l, h = map(int, input().split())
        # 상자를 돌려서 나올 수 있는 가능한 가로, 세로, 높이 조합은 세 가지
        # 각각을 다른 상자로 볼 것이고, 실제로 같은 상자인지는 구별할 수 있어야 하므로 i(박스의 번호)를 추가로 저장한다.
        boxes.append((w, l, h, i))
        boxes.append((w, h, l, i))
        boxes.append((l, h, w, i))

    # 박스들을 면적순으로 정렬한다.
    # 면적이 더 작은 상자는 더 큰 상자 위에 쌓일 가능성이 있으나, 면적이 더 큰 상자는 절대 면적이 더 작은 상자 위에 쌓일 수 없다.
    boxes = sorted(boxes, key=lambda x: (x[0]*x[1]))
    # 맨 위(면적이 가장 적은) 상자부터 놓는다고 생각할 때 현재 놓은 상자를 포함해 만들 수 있는 최대 높이
    dp = [0]*(N*3)
    # 상자들을 쌓을 때 실제로 같은 상자인 경우(즉, i가 같은 경우) 당연히 중복해서 쌓을 수 없다.
    # 이를 확인하기 위해 각 dp 상황에서 각 i번째 상자가 갖는 높이, 없으면 0을 갖는 dp_h 리스트를 만든다.
    dp_h = [[0]*N for _ in range(N*3)]
    dp[0] = boxes[0][2]
    dp_h[0][boxes[0][3]] = boxes[0][2]
    for i in range(1, N*3):
        # 현재 상자
        cur = boxes[i]
        dp_i_candidate = []
        for j in range(i-1, -1, -1):
            # 면적이 더 작은 상자
            pre = boxes[j]
            # 이 조건을 만족하면 가로, 세로 범위 안에 들어와 위에 쌓일 수 있게 된다.
            if (cur[0] >= pre[0] and cur[1] >= pre[1]) or (cur[0] >= pre[1] and cur[1] >= pre[0]):
                # 현재 상자의 위에 쌓으려고 보니 이미 현재 상자와 실제로 같은 상자가 이미 사용된 경우,
                # 기존에 사용된 상자 높이를 없애고 현재 상자 높이를 대신 넣어서 dp를 구한다.
                if dp_h[j][cur[3]]:
                    dp_i_candidate.append((dp[j] - dp_h[j][cur[3]] + cur[2], j))
                else:
                    dp_i_candidate.append((dp[j] + cur[2], j))
        # dp 후보군 중에 가장 최대 높이를 갖는 dp를 택한다. 동시에 dp_h를 해당 dp의 경우에 맞게 세팅해준다.
        if dp_i_candidate:
            dp_pick = max(dp_i_candidate)
            dp[i] = dp_pick[0]
            dp_h[i] = list(dp_h[dp_pick[1]])
            dp_h[i][cur[3]] = cur[2]
        # dp 후보군이 없다면 현재 상자 혼자서만 탑을 쌓는 것이 가능한 상태이다.
        else:
            dp[i] = cur[2]
            dp_h[i][cur[3]] = cur[2]
    
    # 완성된 dp중 최댓값이 가장 높이 쌓을 수 있는 탑의 높이
    print('#%d %d' % (t, max(dp)))

