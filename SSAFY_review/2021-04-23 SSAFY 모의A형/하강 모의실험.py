# 하강 모의실험
# N*N 격자판 상에서 하강 모의실험을 한다. 격자판의 맨 위(제1행)에 있는 셀에 블록이 있으면 하강을 시도한다.
# 블록이 내려가다가 만나는 블록은 해당 블록이 포함된 블록덩어리의 무게만큼 저항력을 갖고 있다.
# 이 저항력을 이겨야 합쳐서 하강할 수 있다. 만일 힘이 모자라면 그 자리에 멈춘다. 하나의 블록은 처음에 1의 힘으로 하강을 시도한다.
# 블록 또는 블록덩어리는 한 칸을 하강할 때마다 힘이 1.9배가 된다.
# 두 칸을 내려가면 1.9*1.9, 즉, 3.61배가 된다. 4개의 블록으로 이루어진 덩어리가 3칸을 하강한 직후 이 덩어리의 힘(하강력)은 4*1.9*1.9*1.9, 즉, 27.4가 된다.
# 하강하는 과정에서 자리잡고 있는 장애물 즉, 블록 또는 블록덩어리는 덩어리의 크기(블록의 수) 만큼의 저항력을 갖고 있다.
# 그림 1에서 블록 M을 포함하는 4개짜리 덩어리는 4의 저항력을 갖고 있다.
# 즉, 4개로 이루어진 덩어리는 4를 초과하는 하강력이 주어져야 비로소 하강을 시작하고 그렇지 않으면 그 자리에서 버틴다.
# 블록들은 수직으로만 영향을 미칠 뿐 다른 열에 있는 블록에는 전혀 영향을 미치지 않는다.

# 이렇게 얻은 결과물로부터 이번에는 중력을 오른쪽으로 작용시켜 블록을 이동시킨다.(이를 우측 하강이라 하자.) 원리는 힘이 우측으로 작용할 뿐 계산 원리는 앞과 같다.
# 이번에는 블록들이 오른쪽으로만 영향을 미칠 뿐 다른 행에 있는 블록에는 전혀 영향을 미치지 않는다.
# 그림 2의 경우 맨 왼쪽(제1열)에는 블록 V밖에 없으므로 블록 V가 있는 3행만 영향을 받는다.

# 장애물들을 가진 N*N 격자판의 상태가 주어질 때, 맨 윗줄(제1행)에 있는 블록들을 동시에 하강시킨 후,
# 이 결과로부터 맨 왼쪽열(제1열)에 있는 블록들을 동시에 우측 하강시킨 결과를 알아내는 프로그램을 작성하라.
# 답으로는 간명함을 위해 격자판의 변한 모양 전체를 묘사하지 말고 맨 아래 행에 자리한 블록의 수와 맨 오른쪽 열에 자리한 블록의 수를 차례로 나열하라.
# 위의 예에서는 맨 아래 행에 자리한 블록의 수는 4개 이며, 맨 오른쪽 열에 자리한 블록의 수 역시 4이다.


# 하강시키는 알고리즘만 만들고, 그래프를 90도 돌려서 재실행한다.
def descent(arr):
    # 하강할 블록 구하기
    start = []
    for i in range(N):
        if arr[0][i]:
            start.append(i)

    # 각 하강 블록에 대한 시행
    for c in start:
        # cnt: 총 하강하는 블록 수, power: 하강하는 블록 덩어리의 힘, r: 행
        cnt = 1
        power = 1
        r = 0
        while True:
            r += 1
            # 끝까지 다 내려왔으면 종료
            if r == N:
                break

            # 자리잡고 있는 블록을 만나면
            if arr[r][c]:
                # 저항력은 총 블록 덩어리의 블록 수
                regist = find_block(r, c)
                # 하강력이 저항력보다 크다면 그 블록을 흡수하고, cnt를 1늘린다.
                # 여기서 cnt를 블록 덩어리 수만큼 늘리지 않는 이유는 당장 arr을 갱신시키지 않기 때문이다.
                # 즉 원본 arr에서 기존에 블록이 자리잡고 있던 만큼 cnt가 올라간다.
                if power > regist:
                    power += regist
                    cnt += 1
                else:
                    break
            power *= 1.9

        # 이제 arr을 갱신시키기 위해서 도달한 행 이전을 전부 0으로 비우기
        for j in range(r):
            arr[j][c] = 0

        # 도달한 행 위부터 cnt이전만큼을 1로 채운다. 즉, 도달한 행 위에 있던 블록의 개수만큼 행 위에 쌓는다.
        for j in range(r-1, r-1-cnt, -1):
            arr[j][c] = 1


# 하강하다가 부딪힌 블록 덩어리가 총 몇 칸인지
def find_block(r, c):
    cnt = 0
    while r < N and arr[r][c]:
        cnt += 1
        r += 1

    return cnt


# 90도 회전
def turn90(arr):
    # arr[r][c] -> arr[c][N-1-r]. 즉, arr[c][N-1-r]에 arr[r][c]를 넣으면 된다.
    copy_arr = []
    for row in arr:
        copy_arr.append(list(row))

    for r in range(N):
        for c in range(N):
            arr[c][N-1-r] = copy_arr[r][c]


for t in range(1, 11):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    descent(arr)
    for row in arr:
        print(row)
    turn90(arr)
    descent(arr)
    cnt1 = 0
    cnt2 = 0
    for i in range(N):
        cnt1 += arr[i][0]
        cnt2 += arr[N-1][i]

    print('#%d %d %d' % (t, cnt1, cnt2))
