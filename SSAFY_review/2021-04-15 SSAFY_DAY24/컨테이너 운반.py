# 컨테이너 운반
# 화물이 실려 있는 N개의 컨테이너를 M대의 트럭으로 A도시에서 B도시로 운반하려고 한다.
# 트럭당 한 개의 컨테이너를 운반 할 수 있고, 트럭의 적재용량을 초과하는 컨테이너는 운반할 수 없다.
# 컨테이너마다 실린 화물의 무게와 트럭마다의 적재용량이 주어지고, A도시에서 B도시로 최대 M대의 트럭이 편도로 한번 만 운행한다고 한다.
# 이때 이동한 화물의 총 중량이 최대가 되도록 컨테이너를 옮겼다면, 옮겨진 화물의 전체 무게가 얼마인지 출력하는 프로그램을 만드시오.
# 화물을 싣지 못한 트럭이 있을 수도 있고, 남는 화물이 있을 수도 있다. 컨테이너를 한 개도 옮길 수 없는 경우 0을 출력한다.


# [입력]
# 첫 줄에 테스트케이스의 수 T가 주어진다. 1<=T<=50
# 다음 줄부터 테스트 케이스의 별로 첫 줄에 컨테이너 수 N과 트럭 수 M이 주어지고, 다음 줄에 N개의 화물이 무게wi, 그 다음 줄에 M개 트럭의 적재용량 ti가 주어진다.
# 1<=N, M<=100, 1<=wi, ti<=50


# [출력]
# 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.


for t in range(1, int(input())+1):
    N, M = map(int, input().split())
    # 컨테이너, 트럭 모두 내림차순 정렬
    container = sorted(list(map(int, input().split())), reverse=True)
    truck = sorted(list(map(int, input().split())), reverse=True)
    result = 0
    # 만약 컨테이너의 가장 작은 것이 트럭의 가장 큰 것보다 크면 운반 불가능
    if container[-1] <= truck[0]:
        # 컨테이너와 트럭의 처음부터 시작해서
        ci, ti = 0, 0
        # 한쪽이 다 닳을 떄까지
        while ci < N and ti < M:
            # 가장 많이 나를 수 있는 트럭부터 가장 큰 컨테이너를 나를 수 있다면 나르고, 다음 트럭이 온다.
            if truck[ti] >= container[ci]:
                result += container[ci]
                ti += 1
            # 나른다면 다음 컨테이너가 오고, 못나른다해도 더 가벼운 다음 컨테이너가 와야 하므로 어차피 다음 컨테이너가 무조건 온다.
            ci += 1

    print('#%d %d' %(t, result))