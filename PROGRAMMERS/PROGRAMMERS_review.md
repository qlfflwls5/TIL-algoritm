# PROGRAMMERS_review

> PROGRAMMERS https://programmers.co.kr/

<br/>

<br/>

## 2021-04-15

+ 프로그래머스에서 진행하는 월간 코드 챌린지에 도전하기 위해 이전 코드 챌린지의 문제들을 풀어보았다.
+ **두 개 뽑아서 더하기, 삼각 달팽이, 풍선 터뜨리기**
+ **조합, 델타 검색, 배열, CT**의 기법을 사용했다.
+ 4문제가 나오며 2문제는 쉽고 2문제는 어려운 느낌인데, 마지막 어려운 문제는 제대로 배우지 않은 DP영역인 데다가 너무 어려워 보여서 아직 손을 못댔다.
+ 두 개 뽑아서 더하기 문제와 삼각 달팽이는 쉽게 풀 수 있었고, 풍선 터뜨리기는 어떻게 문제를 풀어나가야 할 지에 대한 사고력이 필요했다.
  + 풍선 터뜨리기가 그리디의 느낌인지 잘 모르겠다.
+ 느낀점 및 배운점
  + 사실 그리디, CT, DP 이런 것들을 배우면서 얼마나 잘 쓰일지 의문이 들었다.
  + 그러나 프로그래머스에서 진행하는 코드 챌린지에서도 내가 배웠던 영역의 문제들이 나오니 마음의 안정이 생겼다!
  + 열심히 하자!

<br/>

## 2021-04-15 (2)

+ 프로그래머스에서 진행하는 월간 코드 챌린지2탄에 도전했다.
  + **진짜 챌린지에 도전한 것이다!**
+ **절대값 원본들의 합, 올바른 괄호 문자열, 가중치 트리**
+ **산술, 스택, 트리**의 기법을 사용했다.
+ 4문제가 나왔고, 역시 제일 어려운 마지막 문제는 배운 영역이 아니라 풀지 못했다.
  + 사실 3번인 가중치 트리도 18개의 케이스 중에 15개를 맞고 3개가 시간초과였다.
    + 로직은 맞았으나, 문제를 푸는 방법을 몰라서인 것 같다.
    + 들려오는 소문엔 위상정렬과 DP같은 것을 배워야 한다고 한다.
+ **그래도 5000명의 참가자 중 260등을 했다!**
+ 느낀점 및 배운점
  + 이러한 외부에서의 알고리즘 코딩 풀이는 처음 참여해보았다.
    + **원래 오늘은 알고리즘 스터디가 있는 날이지만, 끈질기게 팀원을 설득한 끝에 모두 참여시켰다 ㅎㅎ**
    + 그리고 모두에게 멘탈 붕괴를 선사해줬다.
  + 세상에 고수는 많다.
    + 4문제를 42분만에 풀고 나간 사람이 있다.
    + 나도 저런 사람이 되자.

<br/>

## 2021-04-20

+ 네이버 코딩테스트에 대비, 프로그래머스의 코딩 테스트 고득 kit 문제들을 풀어보았다.(낮은 난이도)
+ **K번째 수, 모의고사, 타겟 넘버, 완주하지 못한 선수**
+ **정렬, 완전 탐색, 해시, DFS**의 기법을 사용했다.
+ 4문제 모두 쉬운 난이도로 어렵지는 않았다. 35분 완료
  + 하지만, 다른 사람들의 풀이를 보니 너무 대단한 것들이 많았다. 보면서 공부하자.
  + 특히, 나는 완전 탐색과 해시 분류의 문제를 해당 알고리즘 기법으로 푼 것 같지는 않다.
+ 느낀점 및 배운점
  + 네이버 코딩테스트는 특히 정보가 없어서 대비하기가 더 어렵다.
  + 배운지 얼마 되지는 않았지만 꾸준히 알고리즘 공부를 해왔으니 최선만 다 해보자!

<br/>

## 2021-04-22

+ 네이버 코딩테스트에 대비, 프로그래머스의 코딩 테스트 고득 kit 문제들을 풀어보았다.(높은 난이도)
+ **다리를 지나는 트럭, 체육복, 입국심사, 가장 먼 노드, DP-N으로 표현**
+ **큐, 그리디, 이진탐색, BFS, DP**의 기법을 사용했다.
+ 굉장히 어려웠다. 혼자 힘으로 푼 것은 큐, 그리디, BFS의 세 문제이다.
  + 이진탐색은 아이디어를 보고 코딩으로 구현해서 성공했다.
  + DP는 아예 배우지를 않아 풀지 못하고 같이 스터디를 하는 형의 풀이를 설명으로 들었다.
    + 설명으로 들어도 이걸 짤 수 있을까 싶다. 많은 경험이 필요해 보인다.
+ 느낀점 및 배운점
  + 어제까지 쉬운 문제를 풀어서 자신감이 매우 올라와있었는데, 실제 코테와 비슷한 난이도라는 문제들을 풀고 현실을 깨달았다.
  + 가장 중요한 것은 우선 문제가 어느 기법을 사용해야 하는 것인지를 파악하는 것이다. 기법을 알고 풀어도 어려운데, 문제를 꼼꼼히 읽고 전체적인 파악부터 해야할 것 같다.

<br/>

## 2021-05-13

+ 프로그래머스에서 진행하는 월간 코드 챌린지2탄 2번째 테스트에 도전했다.
+ **110 사전, 비트 연산, 약수 개수 구하기**
+ **그리디, 비트 연산 **의 기법을 사용했다.
+ 이번에도 첫 번째 문제와 두 번째 문제밖에 맞추지 못했다. 세 번째 문제인 100사전은 주어진 예제 케이스는 맞았으나 실제 테스트 케이스를 맞추지 못했다.
+ 느낀점 및 배운점
  + 실제 코딩 테스트에서는 주어지는 조건을 모두 만족할 수 있도록 case를 완벽하게 짜는 문제들이 나오는 것 같다.
    + 110 사전 같은 경우가 하나하나 모든 경우를 잘 따져봐야 하는 문제인 것 같다.
  + 결국 나는 프로그래머스 월간 코드 챌린지2탄에서 총 4개의 문제를 통과하여 **챌린지를 통과하였다!**

<br/>

## 2021-06-22

+ 프로그래머스에서 월간 코드 챌린지 시즌1 레벨1~3의 문제 3개를 풀었다. 
+ **3진법 뒤집기, 삼각 달팽이, 풍선 터뜨리기**
+ **진법, 델타**의 기법을 사용했다.
+ 이번 3개의 문제 모두 **얼마나 코드를 가독성 있게, 효율성 있게, 시간 복잡도를 줄이게** 짜느냐가 관건이었다.
  + 이번 3개의 문제는 모두 내 코드가 제일 좋았다!
+ **3진법 뒤집기**는 주어진 10진수를 3진수로 만들고 이를 뒤집은 3진수를 10진법으로 변환한 값을 구하는 것이다.
  + 이를 풀면서 3진수로 만들고, 뒤집고, 10진수를 읽는 과정을 따로 구현한 것이 아니라 모두 한 번에 진행되도록 구성했다.
  + 간단하지만 스터디원들에게 백점 만점을 받았다. ㅎㅎ

```python
# 3으로 나눈 나머지를 answer로 담고 answer를 3곱하면 쉬프트가 일어난다.
# 스터디원들에게 최고의 평가를 받은 풀이...ㅎ
def solution(n):
    answer = 0
    while n:
        answer = answer * 3 + n % 3
        n //= 3

    return answer
```

+ **삼각 달팽이**는 전형적인 달팽이 문제로, 델타와 배열의 크기를 잘 이용하면 풀 수 있었다.
+ **풍선 터뜨리기**는 주어진 문제에 담겨진 규칙이 무엇인지를 정확히 알아야 하고, 이를 그대로 구현하면 시간 초과가 나며 효율적으로 구현했을 때에만 통과할 수 있는 문제였다.
  + 다른 스터디원들은 리스트의 최소, 최대를 구하는 과정에서 min함수나 슬라이싱 등을 사용하여 시간 초과가 발생했던 것 같다.
  + 이런 상황에서는 **인덱스를 변경하면서 최소값을 구하고 최소값을 저장해 둔 뒤 쓰는 방식**으로 해야지만 순회를 제거해 시간 복잡도를 줄일 수 있다.

+ 느낀점 및 배운점
  + 효율적이고도 가독성이 높은 코드를 짜서 너무 만족한다.
  + 물론 어려운 문제들은 아니므로... 더 열심히 하자!

<br/>

## 2021-06-29

+ 프로그래머스에서 월간 코드 챌린지 시즌1 레벨1~3의 문제 3개를 풀었다. 

+ **내적, 이진 변환 반복하기, 스타 수열**

+ **진법, 재귀, lambda, 카운터**의 기법을 사용했다.

+ **스타 수열** 문제 빼고는 무난했다. 스타 수열은 **리스트에서 등장하는 숫자의 개수 순으로 숫자를 정렬하는 방법**을 찾는 것이 관건이었다.

  + 즉, `a = [0, 3, 3, 0, 7, 2, 0, 2, 2, 0]`이라는 리스트가 있을 때 0이 4개, 2가 3개, 3이 2개, 7이 1개이므로 우리가 원하는 정렬은 `[0, 2, 3, 7]`의 형태다.

  + 이를 구현하기 위해서는 카운트 리스트를 직접 만들고 인덱스와 값을 통해 딕셔너리를 만드는 방법으로 각 숫자에 대한 개수의 key:value 형태 자료구조를 만들어도 좋지만, 이런 기능을 바로 해주는 **collections**의 **Counter**라는 라이브러리가 있다. 위와 같은 예의 경우 `Counter({0: 4, 2: 3, 3: 2, 7: 1})` 와 같은 객체가 생성된다.

  + 이제, 이를 딕셔너리 value를 기준으로 key를 내림차순하면 된다는 생각이 드는데, 그것을 구현해보자면 다음과 같이 된다.

    ```python
    sorted_cnt_lst = sorted(counter.keys(), reverse=True, key=lambda x: counter[x])
    ```

    즉, **lambda**를 이용하여 각 키에 대한 값을 기준으로 키를 내림차순 하면 되는 것이다.

  + 이렇게 개수를 통해 정렬하고 나면 그 이후의 로직은 어렵지 않다.

+ 느낀점 및 배운점

  + 스타 수열과 같은 문제에서 함부로 카운트 리스트와 `index()`함수를 사용해서 값을 구하려고 하면 안된다. `index()`함수는 리스트의 처음부터 시작해 해당하는 값에 대한 인덱스를 반환할 뿐이기 때문에 만약 2와 3의 개수가 동일하게 4라면 둘 중 하나만 중복하여 두 번 반환하기 때문이다. 조심하자.

<br/>

## 2021-06-30

+ 지인의 풀어달라는 부탁으로 프로그래머스에서 COS PRO 1급 문제 1개를 풀었다. 
+ **꽃 피우기**
+ **BFS**의 기법을 사용했다.
+ BFS 기법을 사용할 때는 queue를 사용하는데, 이 때 `pop(0)`의 과정에서 O(n)의 시간 복잡도를 갖는다. 따라서, 이를 O(1)로 줄이기 위하여 queue에 요소를 추가할 때는 `append()`를 사용하지만 요소를 빼올 때는 인덱스를 사용해 요소를 읽어오는 것이 좋다. 즉, 빼올 요소의 위치를 저장하는 `rear`라는 변수 하나를 놓고 풀면 시간 복잡도를 크게 줄일 수 있다.
+ 또한 이 문제에서는 그래프 탐색에서 흔히 사용하는 `visited`배열을 만들 필요가 없다. 격자판 그 자체를 visited로 활용할 수 있고 거리 정보를 담는 용도로도 사용할 수 있기 때문에, 로직만 잘 짠다면 메모리와 시간 모두 아낄 수 있다.
+ 느낀점 및 배운점

  + 항상 기본이 제일 중요하다. 그 기본에서 얼마나 잘 활용할 수 있는가가 능력이다. 지인의 부탁으로 풀게 된 문제지만 좋은 경험이었다.

<br/>

## 2021-07-06

+ 프로그래머스에서 2018 카카오 블라인드 채용 레벨1~3의 문제 3개를 풀었다. 
+ **비밀지도, 뉴스클러스터링, 추석 트래픽**
+ **이진법, 딕셔너리 및 카운터, 복잡한 상태 구현**
+ **비밀 지도**의 경우에는 팀원의 풀이에서 인상적인 부분을 발견했다.
  + `num = bin(arr1[i] | arr2[i])[2:]`와 같이 `bin()`함수를 사용하는 동시에 미리 비트연산을 실행하면 비트를 이용한 계산 등을 더 효과적으로 빠르게 실행할 수 있다.
    + 이 문제의 경우 각 비트 자리를 비교해 1이 있는 자리를 알아내는 것이기 때문에 위 `|`연산이 효과적으로 사용된다.
+ **뉴스클러스터링**에서도 팀원의 풀이에서 새로운 것을 배웠다. python에서는 collections라는 모듈에서 Counter라는 좋은 클래스를 제공한다. 근데, 이 Counter는 놀랍게도 **딕셔너리에서는 불가능한 key의 집합 연산이 가능하다.** 
  + 아래 코드와 같이, `&`와 `|`의 집합 연산이 가능하며 각각 교집합과 합집합 기능을 한다. **이때 중복되는 원소가 있다면 교집합에서는 해당 키의 값들 중 min값을, 합집합은 해당 키의 값들 중 max값을 가져온다.**
    + ex. `a = {1: 2, 2: 3}`, `b = {1: 3, 2: 4}`와 같은 Counter 객체 두 개가 있을 때 `a & b`의 결과는 `{1: 2, 2: 3}`이고 `a | b`의 결과는 `{1: 3, 2: 4}`이다.

```python
def solution(str1, str2):
    set1 = Counter(make_set(str1))
    set2 = Counter(make_set(str2))
    ...

    intersection = sum(list((set1 & set2).values()))
    union = sum(list((set1 | set2).values()))
    answer = int(intersection / union * 65536)

    return answer
```

+ **추석 트래픽**에서는 문제에서 주어진 상황을 구현하는 데에 있어 한 가지 놓친 것이 있어 계속 풀지 못하였다. 2018 카카오 채용 테스트에서 가장 어려운 문제라고 하는데, 그러한 이유가 있었던 것 같다. 
  + 문제를 읽고 이해해야 나중에 이 글을 봤을 때 내가 무엇을 놓쳤는지 알 수 있을 것 같다. 그럼에도 간단히 적어보자면, 나는 **트래픽의 시작 시점과 끝 시점에서 그 뒤로 1초간 다른 트래픽의 시작 시점과 끝 시점이 몇 개가 오는지**만 신경을 썼다. 즉, 트래픽의 시작과 끝만 1초 사이에 겹치면 동시에 처리 된다라고 생각을 해버렸고, 이 생각을 기본으로 깔고 문제를 풀다 보니 오류를 찾기가 어려웠다. 나의 풀이의 오류는 바로 **트래픽의 시작 시점과 끝 시점에서 그 뒤로 1초간 다른 트래픽의 몸통이 있어도 겹쳐 있으므로 동시 처리 된다는 것**을 놓친 것이다. 예를 들어 50 ~ 60의 막대가 있으면 40 ~ 70이나 30 ~ 55처럼 시작과 끝이 사이에 들어가는 막대만 겹친다 생각하고 1 ~ 100과 같은 막대는 겹친다는 것을 떠올리지 못한 것이다. 치명적인 실수였다.

+ 느낀점 및 배운점

  + 최근 Counter를 많이 사용했는데 굉장히 좋은 활용 방법을 배운 것 같다. 교집합과 합집합 자체를 집합 연산으로 바로 구현할 수 있기 때문에 반드시 기억해두자.
  + 추석 트래픽같은 문제에서 내가 막혔던 부분같은 곳은 코딩 테스트에서 실제로 만나게 된다면 정답을 떠올리지 못할 확률이 높다. 어쩔 수 없는 부분인 것 같다. 더 많은 문제를 풀고 경험을 늘리자.

<br/>

## 2021-07-13

+ 프로그래머스에서 2018 카카오 블라인드 채용 레벨1~3의 문제 3개를 풀었다. 
+ **다트 게임, 프렌즈4블록, 셔틀버스**
+ **시뮬레이션 구현, 복잡한 상태 구현, 시간 계산**
+ 전체적으로 난이도가 높았다. 다행히 스터디원 중에 유일하게 다 풀어냈다!
  + 다트 게임은 점수 계산만 주어진 조건에 따라 잘 하면 된다.
  + 프렌즈4블록은 이중배열에서 이루어지는 게임에 대해서 시뮬레이션을 구현하면 되는 문제다.
    + 삭제할 블록들을 찾아 삭제하는 함수와 함께 빈 공간을 채우는 함수를 구현해야 한다.
    + 인덱싱과 로직만 조심하면 잘 풀 수 있다.
  + 시간 계산 문제는 저번 추석 트래픽 문제를 경험으로 삼아 모두 초단위로 바꿔 풀었고, 다행히 로직이 맞아 착착 풀 수 있었다. 시간에 맞춰 일찍 도착하는 사람부터 버스에 채워넣는 방식으로 약간의 그리디 느낌과 함께 풀어냈다.

+ 느낀점 및 배운점

  + 추석 트래픽에서 시간 문제에 대해 초단위로 바꾸는 팁을 배우지 못했다면 아마 시간 계산 문제를 빠르게 풀 수 없었을 것이다.
  + 전부 다 시간 내에 풀어서 만족한다!

<br/>

## 2021-07-20

+ 프로그래머스에서 2019 카카오 블라인드 채용 레벨1~3의 문제 3개를 풀었다. 
+ **실패율, 오픈채팅방, 길 찾기 게임**
+ **딕셔너리, 트리**
+ 이번에도 전체적인 난이도가 매우 높았다. 특히 길 찾기 게임은 오랜만에 트리를 활용하는 문제가 나와 스터디원 전원이 풀지 못하는 사태가 발생했다.
  + 숙제로 길 찾기 게임 문제를 푼 결과, 트리를 잘 운용하고 노드를 채우는 순서를 잘 정해야만 풀 수 있는 문제였다.
+ 느낀점 및 배운점

  + 트리는 조금만 문제를 꼬아도 굉장히 어려워지는 것 같다. 지금은 이중 배열을 통해 트리를 구현 중이지만, 클래스로 구현하는 법도 고려해봐야겠다.

<br/>

## 2021-07-27

+ 프로그래머스에서 Summer/Winter Coding(~2018) 레벨1~3의 문제 3개를 풀었다. 
+ **소수 만들기, 영어 끝말잇기, 숫자 게임**
+ **에라토스테네스의 체, 문자열, 인덱싱**
+ 카카오 코딩 테스트에서 벗어나서 그런지 문제의 난이도가 확 내려갔다.
  + 세 문제를 푸는 데 30분 정도 들어간 것 같다. 좋아해야 되는 걸까?
  + 소수 만들기가 조금 어려웠는데, 전반적으로 세 문제 전부 **코드를 파이써닉하게 깔끔히 쓴 것 같다.**
+ 느낀점 및 배운점

  + 간만에 빠르게 잘풀린 것 같아서 기분이 좋다.

<br/>

## 2021-08-24

+ 프로그래머스에서 Summer/Winter Coding(~2018) 레벨1~2의 문제 2개를 풀었다. 
+ **예산, 방문 길이**
+ **그리디, 딕셔너리**
+ 프로젝트를 끝내고 오랜만에 알고리즘 스터디에서 진행한 문제를 풀어보았다.
  + 무난하게 풀어낼 수 있었는데, 방문길이와 같은 문제의 경우 길을 한 번 갔다가 반대로 가는 경우를 캐치해야만 효율적으로 풀 수 있다는 것이 핵심이었다.
+ 느낀점 및 배운점

  + 꽤 알고리즘 공백기가 있었기 때문에 얼른 다시 감을 되찾아야겠다.
  + 다행히도 면접을 보게 되었으므로 면접까지 잘 마치고 빨리 다시 시작하자!

<br/>

## 2021-08-25

+ 프로그래머스에서 Summer/Winter Coding(~2018) 레벨2의 문제 1개를 풀었다. 
+ **스킬트리**
+ **문자열**
+ 문자열을 활용할 줄 알고, 문제의 엣지 케이스를 파악하면 풀 수 있는 문제다.
  + 문자열 s가 문자열 S에 들어있는지 확인하기 위해서는(같은 순서로) `s in S`와 같이 쓰면 된다.
  + 이 문제에서의 엣지 케이스는 요구되는 스킬트리 순서의 스킬들을 전혀 사용하지 않는 사용자는 순서에 구애받지 않고 무조건 스킬트리 완성이 가능하다는 것이다.
+ 느낀점 및 배운점

  + 이제 로직적인 부분에서 아예 몰라서 구현을 못하거나 하는 부분은 없다.
  + 문제를 더 뜯어보고 엣지 케이스 같은 것들이 언제 발생할 수 있는지를 따져보자.

<br/>

## 2021-08-29

+ 프로그래머스에서  2020 KAKAO BLIND RECRUITMENT 레벨2의 문제 2개를 풀었다. 
+ **문자열 압축, 괄호 변환**
+ **압축 알고리즘, 분할 정복**
+ 문자열 압축 문제는 압축 알고리즘을 활용해서 가장 잘 압축할 수 있는 방법을 찾는 것이다.
  + 압축 알고리즘을 해보면 항상 마지막 문자에 대해 반복문 내에서 처리를 못해 따로 처리해야 하는데, 이때 뒤에 빈 문자열 값을 하나의 요소로 추가하는 것으로 해결할 수 있다.
+ 괄호 변환은 문제에서 주어지는 알고리즘대로 구현하는 것인데, 분할 정복과 같은 알고리즘이 주어졌다.
  + 문제에서 주어지는대로 재귀의 흐름을 잘 파악해서 그대로 구현하면 풀 수 있다.
+ 느낀점 및 배운점

  + 레벨2의 문제라고 하기에는 조금 많이 어려웠다. 전체적으로 카카오 코딩테스트의 난이도가 높은 듯 하다.
  + 이번 두 문제는 전부 예외처리를 잘해줘야 통과가 가능했다. 엣지 케이스를 잘 생각해보자.

<br/>

## 2021-09-03

+ 프로그래머스에서  2020 KAKAO BLIND RECRUITMENT 레벨3의 문제 1개를 풀었다. 

+ **자물쇠와 열쇠**

+ **이중배열의 회전, 두 이중배열 겹치기 **

+ 매우매우 어려운 유형의 문제. 네이버 코딩 테스트의 마지막 문제에 나왔던 퍼즐 맞추기와 비슷한 문제다.

  + 이 문제에서는 열쇠가 자물쇠를 일부 벗어나면서 겹칠 수 있다. 따라서, 열쇠의 길이와 자물쇠의 길이를 적정한 곳에서 사용하는 것이 관건이다.

  + 이중배열을 90도 회전하는 식은 다음과 같다.

    ```python
    # M은 key의 한 변의 길이
    def turn_90(key):
        return [[key[M - j - 1][i] for j in range(M)] for i in range(M)]
    ```

+ 느낀점 및 배운점

  + **프로그래머스에 올라온 풀이들 중에 내 풀이가 가장 짧고 깔끔했다.**
  + 사실 풀면서도 계속 틀리면서 시행착오를 반복하며 나온 풀이라 완벽하게 로직을 세워서 푼 것은 아니라는 것이 아쉽다. 주로 코딩 테스트의 마지막 보스 문제로 등장하는 유형 같은데, 이중배열의 회전과 이중배열끼리 겹치는 로직을 잘 알아두자.

<br/>

## 2021-09-05

+ 프로그래머스에서 고득점 SQL kit의 SELECT 파트를 풀었다. 
+ 총 7문제의 간단한 SELECT, WHERE, ORDER BY, LIMIT를 활용한 문제
+ WHERE 절에서는 프로그래밍과 달리 비교 시에 `=`, `!=`를 사용한다.
+ 느낀점 및 배운점

  + SQL 코딩 테스트를 위해서 프로그래머스에 있는 SQL 고득점 kit를 풀어보려고 한다.
  + 간단한 SELECT 파트부터 시작해 총 여섯 파트를 여유가 있을 때마다 풀 것이다!
  + 이번 SELECT 파트는 다행히 기존에 알고 있던 지식으로 바로 쉽게 풀 수 있었다.

<br/>

## 2021-09-11

+ 프로그래머스에서 고득점 SQL kit의 SUM MIN MAX 파트를 풀었다. 
+ 총 4문제의 간단한 COUNT, MIN, MAX를 활용한 문제
+ 칼럼에서 중복된 값을 제거하기 위해서는 DISTINCT를 붙인다.
  + COUNT 등에서 안쪽에 DISTINCT를 쓴다. `SELECT COUNT(DISTINCT NAME) FROM TABLE`
  + DISTINCT로 칼럼을 지정해주면 자동으로 NULL은 제외된다.
  + 결과물의 칼럼 이름을 지정해줄 수 있다. `SELECT COUNT(DISTINCT NAME) 칼럼명 FROM TABLE`
+ 느낀점 및 배운점

  + DISTINCT와 집계함수에 대해서 배우게 되었다.
  + 특히 DISTINCT는 실무에서 많이 쓰이게 될 것 같다.

<br/>

## 2021-09-13

+ 프로그래머스에서 고득점 SQL kit의 GROUP BY 파트를 풀었다. 
+ 총 4문제의 GROUP BY, HAVING, ORDER BY FIELD(), SET, WITH RECURSIVE AS, LEFT JOIN를 활용한 문제
+ 주석으로 정리된 것이 많다. 코드를 꼭 참고하자.
  + 특히 GROUP BY를 통해서는 COUNT가 0인 것을 잡아낼 수가 없다.
    + 이때, 두 가지 방법이 있다.
      1. SET을 통해 변수를 만들어서 하는법
      2. WITH RECURSIVE를 통해 미리 0의 값을 갖는 가상 테이블을 만들고 조인하는 법
+ 느낀점 및 배운점

  + 갑자기 난이도가 확 올라갔다. 더이상 알고 있던 지식만으로 안되니 구글링을 하면서 익히자.

<br/>

## 2021-09-17

+ 프로그래머스에서 고득점 SQL kit의 IS NULL 파트를 풀었다. 
+ 총 3문제의 IS NULL, IS NOT NULL, IFNULL(칼럼명, '대체 문자열')를 활용한 문제
+ 문법만 안다면 딱히 어려울 것은 없는 문제들이었다.
  + IFNULL을 새로 배웠다.
+ 느낀점 및 배운점

  + 다음 파트부터가 많이 출제되고 어려운 파트라고 한다. 긴장하자

<br/>

## 2021-10-03

+ 프로그래머스에서 고득점 SQL kit의 JOIN 파트를 풀었다. 
+ 총 4문제의 JOIN, SUBSTR, INSTR, LIKE를 활용한 문제
+ JOIN, ON, WHERE로 이어지는 문법으로 두 테이블에서 내가 원하는 부분만을 추출하는 방법을 익히자.
  + https://pearlluck.tistory.com/46 여기에 매우 정리가 잘되어 있다.
  + ON은 조인을 하는 기준으로, 대부분 PK를 같다고 하면 된다.
+ 느낀점 및 배운점

  + 다행히도 JOIN 부분은 문법만 새로 배우고서 모두 풀 수 있었다.
  + 어느 JOIN을 쓰는지 헷갈리지 않을 정도로 익혀놓자.
