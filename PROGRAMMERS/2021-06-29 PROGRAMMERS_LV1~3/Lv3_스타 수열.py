# 스타 수열
# 다음과 같은 것들을 정의합니다.
# 어떤 수열 x의 부분 수열(Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.

# 예를 들어, [1,3]은 [1,2,3,4,5]의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.
# 다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다.
# x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
# x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 {x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]} 의 교집합의 원소의 개수가 1 이상입니다.
# x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1] 입니다.

# 예를 들어, [1,2,1,3,4,1,1,3]은 스타 수열입니다. {1,2}, {1,3}, {4,1}, {1,3} 의 교집합은 {1} 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.
# 1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요.
# 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.


# 제한사항
# a의 길이는 1 이상 500,000 이하입니다.
# a의 모든 수는 0 이상 (a의 길이) 미만입니다.


# 입출력 예
# a	result
# [0]	0
# [5,2,3,3,5,3]	4
# [0,3,3,0,7,2,0,2,2,0]	8


# 핵심은 순서가 유지되어야 한다는 것. 즉, 앞에서부터 차례로 보면 된다는 것
# 등장하는 숫자는 a길이 미만이다.
# 각 숫자에 대해 앞부터 2칸의 집합에 포함되어 있으면 2칸 건너뛰고, 포함되지 않았거나 두 요소가 전부 해당 숫자라면 1칸 건너뛰며 탐색한다.
# 이때, 최적화를 위해서 미리 리스트 a에서의 각 숫자의 개수를 구해놓고, 가장 개수가 많은 숫자부터 탐색을 한다.
# 현재 최대 등장 횟수보다 애초에 숫자의 개수가 적다면 종료한다. 결과는 스타 수열의 길이이므로 최대 등장 횟수 * 2다.
from collections import Counter


def solution(a):
    len_a = len(a)
    # 리스트 a의 길이가 4미만이라면 애초에 불가능
    if len_a < 4:
        return 0
    
    # 리스트 a에서 각 숫자의 개수를 구한다. -> 딕셔너리
    counter = Counter(a)

    # sorted_cnt_lst는 숫자 개수를 기준으로 내림차순한 숫자 리스트다.
    sorted_cnt_lst = sorted(counter.keys(), reverse=True, key=lambda x: counter[x])
    max_cnt = 0
    for num in sorted_cnt_lst:
        # 숫자 개수가 애초에 max_cnt보다 작아지기 시작했다면 더 이상 볼 필요가 없다.
        if counter[num] <= max_cnt:
            break

        l, r, cnt = 0, 1, 0
        while r < len_a:
            # 현재 숫자가 포함되어있는 집합이라면 두 칸 건너뛰기
            if (a[l] == num and a[r] != num) or (a[l] != num and a[r] == num):
                cnt += 1
                l += 2
                r += 2
            # 포함되어 있지 않거나 집합의 모든 요소가 현재 숫자라면 한 칸 건너뛰기
            else:
                l += 1
                r += 1

        max_cnt = max(max_cnt, cnt)

    return max_cnt * 2


print(solution([0, 3, 3, 0, 7, 2, 0, 2, 2, 0]))
