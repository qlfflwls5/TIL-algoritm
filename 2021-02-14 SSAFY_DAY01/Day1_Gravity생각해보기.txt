7 4 2 0 0 6 0 7 0
A                C
B
(최대값 구하기 - 1)
maxV =  최소치/최소치보다 더작은값으로 초기화
N = len(data)
for i in range(N):
   if maxV < data[i] :
        maxV = data[i]
maxV를 최대로 말할 수 있음

Gravity 알고리즘
1. for - 낙차를 구할 위치지정 (마지막 한 개는 제외됨)
1.5 최대낙차 변수 초기화 : ans = -1
2. 1에서 지정된 위치에 대해 낙차구하기
   2-1.  for -  지정 위치 다음 위치부터 끝까지 비교 위치 지정
   2-2. 더 낮은 높이로 쌓인 위치 개수 세기 (낙차)
3. ans < '2에서 구한 낙차' 일때 ans = '2에서 구한 낙차'

1. for - 낙차를 구할 위치지정 (마지막 한 개는 제외됨)
1.5 빈리스트를 준비  my_list = []
2. 1에서 지정된 위치에 대해 낙차구하기
   2-1.  for -  지정 위치 다음 위치부터 끝까지 비교 위치 지정
   2-2. 더 낮은 높이로 쌓인 위치 개수 세기 (낙차)
3. my_list에 2에서 구한 낙차 추가(append)
4. my_list에서 최대값 구하기
(최대값 구하기 - 2)
maxV =  data[0]   # 첫 번째 데이터
N = len(data)
for i in range(1, N):
   if maxV < data[i] :
        maxV = data[i]
maxV를 최대로 말할 수 있음

Q) 왜 회전이 필요없지? 
A) 중력의 방향을 논리적으로 수정할 수 있기 때문에, 위에서 아래라는 고정관념은 버리자! 중력 방향을 왼쪽에서 오른쪽으로 생각하면 된다!

Q) 왜 2차원 배열 안 만들지?
Q) 같은 위치에 쌓인 상자에 대해서는 한 번만 낙차를 구한다
가장 높은 곳에 있는 것에 대해서만! 왜? 
A) 상자는 아래에서 위로 쌓여 나가기 때문에 아래에 있는 것은 낙차가 '무조건' 더 크거나 같다. 따라서 가장 높은 곳에 있는 것에 대해 한 번만 낮차를 구하면 된다

왜? 