# 힙
# 힙(Heap)은 최댓값 혹은 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 자료구조이다.
# 완전이진트리(Complete binary tree)를 기본으로 한 자료구조로서 다음과 같은 힙 속성(property)을 만족한다.
# - A가 B의 부모노드(parent node) 이면, A의 키(key)값과 B의 키값 사이에는 항상 일정한 대소관계가 성립한다.
# 키값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며, 형제노드 사이에서는 일정한 대소관계가 정해지지 않는다.
# 부모노드의 키값이 자식노드의 키값보다 항상 크거나 같은 힙을 '최대 힙', 부모노드의 키값이 자식노드의 키값보다 항상 작거나 같은 힙을 '최소 힙'이라고 부른다.
# 힙의 루트노드(root node)는 힙을 구성하는 노드의 키값 중 최댓값 혹은 최솟값을 가지게 된다.
# 본 문제에서는 최대 힙(max heap)을 올바르게 구현하였는지 확인할 수 있다.
# 초기에 최대 힙이 비어있을 때에 다음의 2가지 연산을 수행하는 프로그램을 작성하자.
# 연산 1. 자연수 x를 삽입
# 연산 2. 최대 힙의 루트 노드의 키값을 출력하고, 해당 노드를 삭제
# 예를 들어, 쿼리가 순서대로 다음과 같이 5개가 주어졌다고 가정해보자.
# 1. 연산 1 - 3을 삽입
# 2. 연산 1 - 5를 삽입
# 3. 연산 2 - 최댓값 출력 후 해당 키값 삭제
# 4. 연산 1 - 1을 삽입
# 5. 연산 2 - 최댓값 출력 후 해당 키값 삭제
# 3번째 연산을 수행할 때를 기준으로 최대 키값은 5이기 때문에 5가 출력되고, 5는 삭제되기 때문에 최대 힙에는 3만 남게 된다.
# 5번째 연산을 수행할 때를 기준으로 최대 키값은 3이기 때문에 3이 출력되고, 3은 삭제되기 때문에 최대 힙에는 1만 남게 된다.
# 만약 가장 큰 키값이 여러 개일 경우에는, 삭제할 때에 그 키값을 가지는 노드들 전부가 삭제되는 것이 아니라, 루트 노드 단 하나만 삭제됨에 주의한다.


# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스마다 첫째 줄에 수행해야하는 연산의 수를 나타내는 자연수 N(1≤N≤105)이 주어진다.
# 둘째 줄부터 N개의 줄에 걸쳐서 순서대로 수행해야하는 연산에 대한 정보가 주어진다.
# 연산 1을 수행해야 한다면 2개의 자연수 '1 x'가 주어지며, x(1≤x≤109)를 최대 힙에 추가하는 연산임을 의미한다.
# 연산 2를 수행해야 한다면 1개의 자연수 '2'가 주어지며, 현재 최대 힙의 루트 노드의 키값을 출력하고 해당 노드를 삭제하는 연산임을 의미한다.


# [출력]
# 각 테스트 케이스마다 첫째 줄에 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 연산 2의 결과들을 공백 하나를 사이에 두고 순서대로 출력한다.
# 만약, 연산 2를 수행해야 하는데 힙에 원소가 없어서 출력해야 할 최대 키값이 존재하지 않는다면 -1을 출력한다.


import heapq


for t in range(1, int(input())+1):
    N = int(input())
    heap = []
    result = []
    for _ in range(N):
        data = list(map(int, input().split()))
        if len(data) == 2:
            # 최대힙 만드는 방법
            heapq.heappush(heap, (-data[1], data[1]))
        else:
            if heap:
                result.append(heapq.heappop(heap)[1])
            else:
                result.append(-1)

    print('#%d %s' % (t, ' '.join(map(str, result))))

# 최대힙 아예 -만 붙여서 저장을 하고 꺼낼 때 다시 -를 붙여보자
