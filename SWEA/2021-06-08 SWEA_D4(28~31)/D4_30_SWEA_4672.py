# 수진이의 팰린드롬
# 수진이는 알파벳 소문자로 이루어진 N자리 단어를 가지고 있다.
# 수진이는 팰린드롬을 좋아하기 때문에, 이 단어를 재구성하여 새로운 단어를 만들고 그 단어의 부분문자열 중에서 팰린드롬인 것들의 개수를 최대화하고 싶어한다.
# 부분문자열이란 어떤 문자열에서 연속한 일부분을 뽑아내 만든 문자열을 의미한다.
# 예를 들어 “abc”의 부분문자열은 “a”, “b”, “c”, “ab”, “bc”, “abc”의 6개가 있다.
# 단, 구성이 같은 부분문자열이더라도 팰린드롬의 개수를 셀 때는 다른 것으로 보고 그 개수를 세줘야 한다.
# 예를 들어 “aaa”의 부분 문자열은 “a”, “a”, “a”, “aa”, “aa”, “aaa”로 “a”가 3개, “aa”가 2개이지만 서로 다른 것으로 보고 모두 개수를 세줘야 한다.


# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스의 첫 번째 줄에는 단어 W가 주어진다.
# 이 단어는 알파벳 소문자 만으로 이루어져 있고, 길이는 1이상 10 이하이다.


# [출력]
# 각 테스트 케이스마다 주어진 문자열을 재구성하였을 때 만든 단어의 부분문자열 중에서 팰린드롬인 것의 개수를 최대화하였을 때의 부분문자열 중 팰린드롬의 수를 출력하라.
# *세 번째 테스트 케이스를 abccba로 바꾸면 팰린드롬인 부분 문자열의 개수가 9개이고 이것이 최대이다.


# abcabc와 같은 경우 aabbcc와 같이 정렬을 할 때 가장 많은 팰린드롬 부분 문자열의 개수를 얻을 수 있다.
for t in range(1, int(input())+1):
    W = input()
    new_W = sorted(list(W))
    result = 0
    stack = []
    for w in new_W:
        if not stack or stack[-1] == w:
            stack.append(w)
        else:
            result += len(stack)*(len(stack)+1)//2
            stack = [w]

    if stack:
        result += len(stack)*(len(stack)+1)//2

    print('#%d %d' % (t, result))