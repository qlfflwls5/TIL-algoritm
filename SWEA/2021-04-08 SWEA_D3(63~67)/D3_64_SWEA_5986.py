# 새샘이와 세 소수
# 정수론에서, 세 소수 문제란 다음과 같다.

# “5보다 큰 모든 홀수는 정확히 세 소수의 합으로 표현될 수 있다. (같은 소수를 합에 사용해도 된다.)”

# 예를 들어, 7 = 2 + 2 + 3, 11 = 2 + 2 + 7, 25 = 7 + 7 + 11로 나타낼 수 있다.
# 1939년 러시아 수학자 I. M. Vinogradov는 충분히 큰 홀수는 세 소수의 합으로 표현할 수 있다는 것을 증명했다.
# 여기서 충분히 크다는 것은 3^3^15 ≈ 10^7000000 이상의 수라는 의미이다.
# 현재 가장 발전된 하한은 약 e^3100 ≈ 10^1346 이상의 수이다.
# 러시아 수학자 I. M. Vinogradov 를 존경하는 새샘이는 직접 세 소수 문제를 풀어보기로 했다.
# 하지만 이 수는 너무 크기 때문에 컴퓨터로도 이 범위까지의 모든 수를 증명할 수는 없었다.
# 대신 어떤 크지 않은 홀수에 대해, 세 소수의 합으로 나타낼 수 있는 경우의 수를 구하기로 했다.
# 5보다 큰 홀수 N을 입력 받아 N = x + y + z (단, x ≤ y ≤ z 이고, x, y, z는 소수) 로 나타나는 경우의 수를 구하는 프로그램을 작성
# 하라.


# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스의 첫 번째 줄에 하나의 정수 N ( 7 ≤ N ≤ 999 ) 이 주어진다.
# N은 홀수이다.


# [출력]
# 각 테스트 케이스마다 첫 번째 줄에는 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,
# N을 세 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.


# 어차피 소수는 변하지 않는다. 미리 만들어 놓는다.
prime_list = []
sieve = [0, 0] + [1]*998
for i in range(2, 1000):
    if sieve[i]:
        prime_list.append(i)
        for j in range(2*i, 1000, i):
            sieve[j] = 0


# 중복조합
def combi(level, start, S):
    if level == 3:
        if S == N:
            global cnt
            cnt += 1
        return

    if S > N:
        return

    for i in range(start, len(prime_list)):
        if prime_list[i] > N-4:
            return
        combi(level+1, i, S+prime_list[i])


for t in range(1, int(input())+1):
    N = int(input())
    cnt = 0
    combi(0, 0, 0)
    print('#%d %d' % (t, cnt))