# 최장 증가 부분 수열
# 주어진 두 수열의 최장 증가 부분 수열(Longest Increasing Subsequence)의 길이를 계산하는 프로그램을 작성하시오.
# 수열 { A1, A2, ... , AN }의 최장 증가 부분 수열 B는 다음과 같이 정의된다.
# { B1, B2, ... , BK }에서 0≤K≤N, B1 ≤ B2 ≤ ... ≤ BK이고,
# AB1 ≤ AB2 ≤ ... ≤ ABK인 최대 K로 구성된 수열이다.
# 예를 들어, 수열이 { 1, 3, 2, 5, 4, 7 } 이라면, 최장 부분 증가 수열의 길이는 4가 된다.


# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스의 첫째 줄에는 수열의 길이 N(1≤N≤1,000)이 주어진다.
# 둘째 줄에는 수열의 원소 N개가 공백을 사이에 두고 순서대로 주어진다.
# 각 수열의 원소는 1 이상 231-1 이하의 자연수이다.


# [출력]
# 각 테스트 케이스마다 ‘#T’(T는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 최대 증가 부분 수열의 길이를 출력한다.


# LIS문제이다. 현재 숫자 이전에 있는 현재 숫자보다 작은 숫자들을 연결 할 때 가장 긴 증가수열이 되는 경우를 들고 간다.
for t in range(1, int(input())+1):
    N = int(input())
    num = list(map(int, input().split()))
    # 각 차례에서의 증가 수열 길이를 담을 카운트 리스트
    cnt_list = [1]*N
    # 두 번째 숫자부터
    for i in range(1, N):
        max_cnt = 0
        # 자신의 이전 숫자들에 대하여, 이전 숫자가 자신보다 작으면서 증가 수열 길이가 가장 길다면
        # 자신의 증가 수열 길이는 해당 숫자의 증가 수열 길이 + 1이다.
        # 즉, 현재 숫자 i의 이전 숫자이면서 i보다 작은 숫자들 중 j의 cnt_list 값이 다른 숫자들의 cnt_list 값보다 클 경우, i의 cnt_list 값은 j의 cnt_list 값 + 1
        for j in range(i-1, -1, -1):
            if num[i] >= num[j] and cnt_list[j] > max_cnt:
                max_cnt = cnt_list[j]
            cnt_list[i] = max_cnt + 1
            # 만약 max_cnt보다 j가 더 작다면 처음부터 j번까지 전부 증가 수열이라고 해도 길이가 max_cnt보다 짧으므로 break
            if j < max_cnt:
                break

    print('#%d %d' % (t, max(cnt_list)))