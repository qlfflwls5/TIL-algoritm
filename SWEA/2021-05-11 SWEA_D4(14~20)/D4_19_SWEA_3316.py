# 동아리실 관리하기
# 삼성초등학교에는 영준, 준환, 동한, 하니 이렇게 네 명이 프로그래밍 동아리에 속해있다. 부원 네 명의 이름을 편의상 A, B, C, D라고 하자.
# 앞으로 N일간의 활동 일정을 정해야 한다.
# 각 부원은 하루의 활동에 참여를 할지 하지 않을지를 정해야 하며, 어떤 부원이 참여하는지의 경우의 수는 하루에 총 16가지이다.
# 그런데 아무도 활동에 참여하지 않으면 동아리가 폐부 될 수 있으므로 아무도 참여를 하지 않아서는 곤란하다.
# 즉 실제로는 15가지 경우가 있다.
# 동아리 실을 여는 열쇠는 하나밖에 없고 활동이 끝나면 동아리 실을 잠가야 하기 때문에 문을 열어주기 위해 열쇠를 가진 사람은 무조건 활동에 참여해야 한다.
# 오늘 활동에 참여하는 사람 중에 내일 활동에도 참여하는 사람이 있다면 열쇠를 넘겨줄 수 있다.
# 첫 번째 날에는 A가 열쇠를 가지고 있다.
# 모든 활동이 끝난 다음에는 열쇠를 누가 가지고 있어도 상관이 없다.
# 또한 N일 동안 각 날마다 활동의 책임자가 있어서 이 책임자는 무조건 활동에 참여해야 한다.
# N일 동안의 동아리 활동을 할 수 있는 경우의 수를 출력하는 프로그램을 작성하라.
# (열쇠를 누구에게 넘겨주는지는 중요하지 않고 어떤 사람이 활동을 하는지 안 하는지에 따라 경우의 수를 세어야 한다.)
# 예를 들어 동아리실 담당자가 첫날에는 B, 둘째 날 C라고 해보자.
# 위의 그림에서 가능한 경우에는 1일차와 2일차에 A가 열쇠를 전달해 주면 된다.
# 하지만 불가능 한 경우에는 1일차 있었던 사람이 2일차에 아무도 없기 때문에 동아리 실을 유지할 수 없게 된다.


# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스마다 길이 10,000 이하인 하나의 문자열이 주어진다. 이 문자열은 A, B, C, D로 이루어져 있으며, i번째 문자는 i번째 날의 책임자가 누구인지를 나타낸다.


# [출력]
# 각 테스트 케이스마다 N일 동안의 동아리 활동을 할 수 있는 경우의 수를 출력하는 프로그램을 작성하라.
# 이 수는 너무 커질 수 있으므로 1,000,000,007로 나눈 나머지를 출력한다.


# 비트연산을 잘 활용해야 한다.
# 아이디어를 듣고 나서 혼자 풀어보았다.
for t in range(1, int(input())+1):
    # 편의상 ord를 이용해 A, B, C, D를 각각 0, 1, 2, 3로 바꾼다.
    data = list(map(lambda x: ord(x) - 65, input()))
    # 매 날마다 15가지의 경우의 수가 있다. 각 경우의 수에 대해 이전의 경우의 수에서 가능할 때, 이전의 경우의 수를 누적해 더한다.
    # 예) 3일 째에 2번째 경우의 수가 4개, 3번째 경우의 수가 3개이고 4일 째에 4번째 경우의 수가 이전의 2번째, 3번째 경우의 수에 연결되어 가능할 때 4번째 경우의 수는 4 + 3 = 7개다.
    case = [[0]*16 for _ in range(len(data))]
    # 첫 날은 열쇠를 가진 사람이 A로 정해져있다. 첫 시행을 따로 해준다.
    for i in range(1, 16):
        if i & 1 and i & 1 << data[0]:
            case[0][i] += 1

    for i in range(1, len(data)):
        # 이 for문은 오늘의 경우의 수에 대해 작업을 하기 위한 for문
        for j in range(1, 16):
            # 이 for문은 이전 날의 경우의 수를 가져오기 위한 for문
            for k in range(1, 16):
                # k & j는 이전 날 참여자 중 한 명이라도 오늘 있는지 확인, j & 1 << data[i]는 오늘 참여자 중 책임자가 있는지 확인
                if k & j and j & 1 << data[i]:
                    # 여기서 1000000007을 계속 나머지 연산하면서 하지 않고 나중에 한 번만 연산을 하면 10배는 더 느려진다. 조심
                    case[i][j] = (case[i][j] + case[i - 1][k]) % 1000000007

    print('#%d %d' % (t, sum(case[-1]) % 1000000007))