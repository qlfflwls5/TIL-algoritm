# 2021.02.17_string&0216복습





## 새롭게 배운 것들



## 1. 문자의 표현

### 1.1 컴퓨터에서의 문자 표현

+ 글자 'A'를 메모리에 저장하는 방법에 대해서 생각해보자
+ 메모리는 **숫자만을 저장할 수 있기 때문에** A라는 글자의 모양 그대로 비트맵으로 저장하는 방법을 사용하지 않는 한(이 방법은 메모리 낭비가 심하다) **각 문자에 대해서 대응되는 숫자를 정해 놓고** 이것을 메모리에 저장하는 방법이 사용될 것이다.
+ 영어가 대소문자 합쳐서 52이므로 **6(64가지)비트**면 모두 표현할 수 있다. 이를 **코드 체계**라고 한다.
  + 000000 => 'a', 000001 => 'b'

+ 그러나 네트워크가 발전되기 전에는 미국의 각 지역 별로 코드체계를 정해 놓고 사용했지만, 네트워크가 발전하면서 서로간에 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생겼다.

+ 그래서 혼동을 피하기 위해 **표준안**을 만들기로 했으며, 1967년 **ACSII**라는 문자 인코딩 표준이 제정되었다.
+ ASCII는 **7bit** 인코딩으로 **128문자**를 표현하며 33개의 출력 불가능한 제어문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.

+ **확장 아스키**는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다. 8bit(1B)
+ 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 ASCII형식을 사용한다.
+ 그런데 컴퓨터가 발전하며서 미국 뿐 아니라 각 나라에서도 컴퓨터가 발전해 각 국가들은 자국의 문자를 표현하기 위하여 코드체계를 만들어서 사용하게 되었다.
  + 우리나라도 한글 코드체계를 만들어 사용했고 **조합형**, **완성형** 두 종류를 가지고 있었다.
+ 하지만 이 또한 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석할 수 밖에 없었다.
+ 그래서 **다국어 처리**를 위해 표준을 마련했다. 이를 **유니코드**라고 한다.
  + 유니코드도 다시 **Character Set**으로 분류된다. UCS-2, UCS-4 ...
  + 그러나 **바이트 순서에 대해서 표준화하지 못했다**. 즉, 인식 시 이 파일이 UCS-2인지 UCS-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제 발생. big-endian, little-endian
  + 그래서 유니코드의 **적당한 외부 인코딩**이 필요하게 되었다.

+ 유니코드 인코딩 (**UTF**: Unicode Transformation Format)
  + UTF-8 (web)
  + UTF-16 (windows, JAVA)
  + UTF-32 (unix)
+ Python 인코딩
  + 2.x 버전 - ASCII -> utf-8 명시 필요
  + 3.x 버전 - 유니코드 UTF-8 -> 생략 가능







## 2. 문자열

### 2.1 문자열의 분류

문자열 - fixed length

​             - variable length - length controlled (java언어에서의 문자열)

​                                           - delimited (c언어에서의 문자열)

#### 2.1.1 Java(객체지향 언어)에서의 문자열 처리

+ 문자열 데이터를 저장, 처리해주는 클래스를 제공한다.
+ String 클래스를 사용한다.

```java
String str = "abc"; //또는 String str = new String("abc")
```

+ 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공한다.
  + +, length()_, replace(), split(), substring(), ...

  

#### 2.1.2 Python에서의 문자열 처리

+ **char타입 없음**

+ **텍스트 데이터의 취급방법이 통일되어 있음**

+ 문자열 기호

  +  ', ", ''', """ (홑따옴표나 쌍따옴표 세 개는 그 안의 내용을 **그대로** 출력한다.)

  + \+ 연결(Concatenation)
  + \* 반복

```python
str1 = '''안녕하세요
안녕하세요
'''
print(str1) # 안녕하세요 enter 안녕하세요

str2 = "안녕"
str3 = "하세요"
print(str2+str3) # 안녕하세요
```

+ 문자열은 **시퀀스 자료형**으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 **인덱싱, 슬라이싱** 연산들을 사용 가능
+ 문자열 클래스에서 제공되는 메소드

```python
replace(), split(), isalpha(), find() ...
```

+ 문자열은 요소값을 변경할 수 없는 **immutable**

```python
# replace()
line = '안녕하세요'
print(line.replace('세', '시')) # 안녕하시요
print(line) # 안녕하세요
# 즉, replace는 값을 리턴하는 메소드. 원본을 변경하는 것이 아니다. -> 불가능하다.

# 원본을 바꾸고 싶다면 이렇게 구현하면 된다.
line = line.replace('세', '시')


# split()
print(line.split('하')) # ['안녕', '세요']


# isalpha()
# 예제) 비밀번호는 영어숫자를 조합해서 작성해야 한다.
password = 'abced'

flag_alpha = False
flag_number = False
for i in password:
    if i.isalpha():
        flag_alpha = True
    if i.isdigit():
        flag_number = True

if not flag_alpha:
    print('비밀번호에 알파벳이 사용되지 않았음')
elif not flag_number:
    print('비밀번호에 숫자가 사용되지 않았음')
else:
    print('비밀번호가 잘 생성되었음')
    
 
# find(), index()
line2 = '안녕하시오'
print(line2.find('녕')) # 1
print(line2.index('녕')) # 1
# find()와 index()의 차이 => find는 없다면 -1 반환, index는 에러
```



#### 2.1.3 문자열 뒤집기

+ 자기 문자열에서 뒤집는 방법이 있고, **새로운 빈 문자열**을 만들어 **소스의 뒤에서부터 읽어서 타겟에 쓰는 방법**이 있다.
+ **자기 문자열**을 이용할 경우는 **swap을 위한 임시 변수**가 필요하며 **반복수행을 문자열 길이의 반**만을 수행해야 한다. 이 경우 **리스트**로 변환한 후 수행한다.(mutable)

+ `reverse()`메소드나 `[::-1]`를 통해 할 수 있지만, 알고리즘적으로 문자열 뒤집기를 할 수 있다.



#### 2.1.4 문자열 비교

+ c에서는 `strcmp()`를, java에서는 `equals()`를 제공한다.

+ 파이썬에서는 `==` 연산자와 `is` 연산자를 제공한다.

  + `==` 연산자는 내부적으로 특수 메소드 `__eq__()`를 호출

  + `==`은 값 비교, `is`는 객체 비교를 한다.



#### 2.1.5 문자열 숫자를 정수로 변환하기

+ c에서는 `atoi()`를, java에서는 `parse`메소드를 제공한다.
+ 파이썬에서는 숫자와 문자변환 함수를 제공한다.
  + `int('123')`, `float('123')`, `str(123)`

```python
def atoi(num_str):
    # 최종 값을 담을 변수
    value = 0
    for i in range(len(num_str)):
        value *= 10
        value += ord(num_str[i]) - ord('0') # 이렇게 하면 해당 숫자가 나온다.
    
    return value


num_str = '1234'
num_int = atoi(num_str)
print(num_int, type(num_int)) # 1234 <class 'int'>
```

+ 위 코드의 역함수는 `itoa`가 될 것이다.
  + 양의 정수를 입력받아 문자열로 변환하는 함수
  + 입력 값: 변환할 정수 값, 변환된 문자열을 저장할 문자배열
  + 반환 값: 없음
  + 음수를 변환할 때는 어떤 고려사항이 필요한가?

```python
def itoa(num):
    result = ''
    # 부호 표현
    sign = ''
    # 음수 처리
    if num < 0:
        num = -num
        sign = '-'
    while num > 0:
        result = chr(num % 10 + ord('0')) + result
        num //= 10

    return sign + result
```







## 3. 0216 복습

### 3.1 특별한 정렬

+ `list_num[:10]`을 슬라이싱 해올 때, `list_num`의 **길이가 10이어도 에러가 안난다!** (중요)
+ 선택정렬, 단순 교환정렬 등을 알아두자. (둘은 비슷하긴 하다)
+ **두 리스트를 가지고 번갈아 값을 가져오고 싶을 때**

```python
a = get_MaxM(num, 5)
b = get_MinM(num, 5)
answer = ['%d %d' % (a[i], b[i]) for i in range(5)]
```

+ **리스트의 요소들을 공백을 두고 가져오고 싶을 때**

```python
result = ' '.join(map(str, lst_num[:10]))
```





### 3.2 사다리

+ 이중 배열의 양 옆에 0을 추가하는 법

`arr = [[0]+list(map(int, input().split()))+[0] for _ in range(N)]`

+ 여기에 위아래까지 0을 추가하는법 (arr가 0으로 둘러쌓인다.)

`arr.append([0]*(N+2))`: 마지막 줄에 추가

`arr.insert([0]*(N+2), 0)`: 첫 째 줄에 추가





### 3.3 부분집합의 합

```python
num = [1,2,3,4,5,6,7,8,9,10,11,12]
Len = len(num)
lst = []
for i in range(1, 1<<Len):
    sub_lst = []
    for j in range(Len):
        if i & (1<<j):
            sub_lst.append(num[j])
    lst.append(sub_lst)

#lst = [ [1], [2], [1, 2], ..., [1,2,3,4,5,6,7,8,9,10,11,12]] : before

TC  = int(input())
for tc in range(1, TC+1):
    N, K = map(int, input().split())
    answer = [1 for i in lst[N] if sum(i) == K]
    print('#%s %d'%(tc, len(answer)))
```

```python
# after
#lst[1] = [ [1], [2], [3], [4], ...[12]]
#lst[2] = [ [1, 2], [1, 3], [1, 4], ....[11, 12]]
num = list(range(1, 13))
Len = len(num)
lst = [ [] for _ in range(13) ]
for i in range(1, 1<<Len):
    sub_lst = [ num[j] for j in range(Len) if i & (1<<j)]
    x = len(sub_lst)
    lst[x].append(sub_lst)

TC = int(input())
for tc in range(1, TC+1):
    N, K = map(int, input().split())
    answer = [1 for s in lst[N] if sum(s) == K]
    print('#%s %d'%(tc, len(answer)))
```







## 4. 문자열 패턴 매칭

+ 패턴 매칭에 사용되는 알고리즘들
  + 고지식한 패턴 검색 알고리즘
  + 카프-라빈 알고리즘 (안배울 것)
  + KMP 알고리즘
  + 보이어-무어 알고리즘

### 4.1 고지식한 알고리즘(Brute Force)

+ 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작

```python
p = 'is' # 찾을 패턴
t = 'This is a book~!' # 전체 텍스트
M = len(p)
N = len(t)

def BruteForce(p, t):
    i = 0 # t의 인덱스
    j = 0 # p의 인덱스
    while j < M and i < N:
        if t[i] != p[j]:
            i = i - j
            j = -1
        i = i + 1
        j = j + 1
    if j == M:
        return i-M # 검색 성공
    else:
        return -1 # 검색 실패
```

+ 시간 복잡도

  + 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨

  + 비교횟수를 줄일 수 있는 방법은 없을까?





### 4.2 KMP 알고리즘

+ 불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
+ 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
  + next[M]: 불일치가 발생했을 경우 이동할 다음 위치
+ 시간 복잡도: O(M+N)

+ 설명
  + T = abcdabcd....
  + p = abcdabcef
  + 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황
  + 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있다.
  + 실패한 텍스트 문자와 p[4]를 비교하면서 다시 시작하면 된다.
+ **매칭이 실패했을 때 돌아갈 곳을 계산해 놓는다.**
  + ex) abcdabcef에서 첫 번째 b, c, d는 첫 번째 a로, 두 번째 a는 첫 번째 a로, 두 번째 b는 첫 번재 b로, 두 번째 c는 첫 번째 c로, 첫 번째 e는 첫 번째 d로, 첫 번째 f는 첫 번째 a로(f앞의 abce는 그 앞의 abcd와 다르므로 맨 처음으로 돌아가야한다.)
  + 이를 리스트로 표현하면 [0, 0, 0, 0, 0, 1, 2, 3, 0]





### 4.3 보이어-무어 알고리즘

+ 오른쪽에서 왼쪽으로 비교(끝부터)
+ 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
+ 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이 만큼이 된다.

+ 패턴 내에 존재하는 경우 패턴에서 일치하는 문자를 찾아서 점프
  + 이 스킵 배열은 거꾸로 인덱스다.
  + 예) 패턴이 'rithm'일 경우
  + m = 0, h = 1, t = 2, i = 3, r = 4, 없는 문자 = 5 가 스킵 배열이 된다.





### 4.4 문자열 매칭 알고리즘 비교

+ 찾고자 하는 문자열 패턴 길이가 m, 총 문자열 길이가 n일 때,
+ 고지식한 패턴 검색 알고리즘: O(mn)
+ 카프-라빈 알고리즘: O(n) (변동가능)
+ KMP알고리즘: O(n) (변동가능)
+ 보이어-무어 알고리즘
  + 최선의 경우 O(n)
  + 이 알고리즘은 텍스트 문자를 다 보지 않아도 된다.
  + 발상의 전환: 패턴의 오른쪽부터 비교한다.
  + 최악의 경우 O(mn)
  + 입력에 따라 다르지만 보통 O(n) (변동가능)보다 시간이 덜 든다.







## 5. 문자열 암호화

### 5.1 시저 암호

+ 쥴리어스 시저가 사용했다고 하는 암호이다.
+ 시저 암호에서는 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 [평행이동]시킴으로써 암호화를 행한다.

+ 시저 암호문에 대한 전사공격: 0~25번을 밀었을 때를 검사





### 5.2 문자 변환표를 이용한 암호화(단일 치환 암호)

+ 단순한 시저 암호화보다 훨씬 강력한 암호화 기법
+ 변환표가 미리 주어져있다.
+ 단일 치환 암호의 복호화
  + 복호화 하기 위해서는 모든 키의 조합(key space)가 필요하다.
+ 단일 치환 암호의 키의 총 수는
  + 26\*25\*24\*.......\*1 = 26! = 1초에 10억개의 키를 적용하는 속도로 조사해도 모든 키를 조사하는 데 120억년이 걸림





### 5.3 bit열의 암호화

+ 배타적 논리합(exclusive-or) 연산 사용 (서로 다를 때만 1이 나온다)
+ 평문 - 키 - 암호문 구조
+ 키만 있으면 평문과 암호문을 서로 변환할 수 있다.







## 6. 문자열 압축

+ 다음과 같은 문자열이 있다. 저장소의 크기를 줄이며 정확한 정보를 저장하는 방법은?
  + Run-length encoding 알고리즘
  + 같은 값이 몇 번 반복되는가를 나타냄으로써 압축

```python
[A, B, B, B, B, B, B, B, B, A]
[A, 1, B, 8, A, 1]
```

+ 이 방법은 이미지 파일포맷 중 BMP 파일포맷의 압축 방법이다.
+ 좀 더 효율적이고 일반적인 압축방법은 없는가?
  + 허프만 코딩 알고리즘이 있다.