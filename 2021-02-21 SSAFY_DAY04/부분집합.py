# 부분집합
# 부분집합 합 문제 구현하기
# 10개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내보자
# 예를 들어, [ -7, -3, -2, 5, 8]라는 집합이 있을 때, [-3, -2, 5]는 이 집합의 부분집합이면서 (-3)+(-2)+5=0이므로 이 경우의 답은 참이 된다.
# 실제로 10개의 정수를 입력 받아 부분집합의 합이 0이 되는 것이 존재하는지를 계산하는 함수를 작성해보자.
# 존재하는 경우 1  존재하지 않는 경우 0 을 출력하도록 한다


import sys
sys.stdin = open("부분집합_input.txt")


T = int(input())
for t in range(1, T+1):
    arr = list(map(int, input().split()))
    # 편의상 N이라는 변수에 arr의 전체 길이를 담는다.
    N = len(arr)
    # 부분집합 중 합이 0인 것이 있으면 result를 1로 하고 반복문을 바로 종료할 것이다.
    result = 0
    # 1 << N은 N길이의 리스트가 갖는 전체 부분집합의 개수. i는 각 부분집합의 길이가 된다.
    # 공집합이면 부분집합의 합을 구하는 for문이 실행이 안될 것이고 total이 0이 되므로 이를 걸러내기 위해 길이(i)가 0일 때를 제외
    for i in range(1, 1 << N):
        # 각 부분집합의 합을 담을 변수 생성
        total = 0
        # i를 2진수로 표현한 것에서 1이 있는 위치와 대응하여 해당 인덱스의 arr값을 total에 더해 나간다.
        # ex) i가 0010100111이라면 arr[0], arr[1], arr[2], arr[5], arr[7]의 합이 total에 담긴다.
        # 이를 range(N)을 순회하는 j를 사용하여 i & (1 << j)를 통해 구현한다.
        # ex) i가 0010100111이라면 j가 0, 1, 2, 5, 7일 때 i & (1 << j)가 1이 된다.
        for j in range(N):
            if i & (1 << j):
                total += arr[j]
        # total이 0이면서 부분집합의 길이가 0이 아닐 때에 result를 1로 바꾸고 반복을 끝낸다.
        if total == 0:
            result = 1
            break
    print('#%d %d' %(t, result))