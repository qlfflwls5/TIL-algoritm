# BAEKJOON_review

> BAEKJOON ONLINE JUDGE https://www.acmicpc.net/

<br/>

<br/>

## 2021-02-11

+ 백준 1단계 문제의 단계순 1번 ~ 11번 문제를 풀었다. 1단계 완료!
+ **Hello World출력, 격려의 문구, 고양이, 강아지, 더하기, 빼기, 곱하기, 나누기, 나머지, 곱셈의 과정**
+ 알고리즘의 기초가 되는 **사칙연산**의 매우 간단한 문제들이었다.
+ **나머지의 특성**과 **정수에서 각 자릿수를 가져오는 방식**이 이번 회의 포인트였다.

```python
# 나머지의 특성
(A+B) % C == ((A%C) + (B%C)) % C
(A*B) % C == ((A%C) * (B%C)) % C
```

```python
# 정수에서 각 자릿수를 가져오는 방식
while num > 0:
    num % 10 # 이게 각 자릿수가 된다.
    num //= 10
```

+ 느낀점 및 배운 것들
  + 기초가 탄탄해야 한다.
  + 앞으로의 모든 알고리즘에서 최대한 내장함수를 사용하지 않을 것이다.
  + 오늘 배운 이 기본 사칙연산들이 알고리즘의 근간이 될 것이다.

<br/>

## 2021-02-13

+ 백준 2단계 문제의 단계순 1번 ~ 5번 문제를 풀었다. 2단계 완료!
+ **두 수 비교하기, 시험 성적, 윤년, 알람시계, 사분면 고르기**
+ **if문**에 대한 간단한 문제들이었다.
+ **분기를 어떻게 나누는가**는 코드의 길이와 불필요한 실행을 줄이는데에 직결된다.

```python
# x, y의 값을 입력받고 몇 사분면에 위치하는지 찾는 문제
# 단순히 x의 부호와 y의 부호를 하나하나 따져 찾는 방법
A = int(input())
B = int(input())

if A > 0 and B > 0:
    result = 1
elif A > 0 and B < 0:
    result = 4
elif A < 0 and B > 0:
    result = 2
else:
    result = 3
```

```python
# x와 y를 곱한 것을 토대로 찾는 방법
A = int(input())
B = int(input())
if A*B > 0 :
    if A > 0:
        result = 1
    else:
        result = 3
else:
    if A > 0:
        result = 4
    else:
        result = 2
```

+ 후자의 경우 **직관성**은 떨어질 수 있어도 **코드 작성이 줄고 편리하다.**
+ 줄이 더 많아보이는가? 그러나...

```python
# 후자의 코드를 삼항연산자로 표현하면
A = int(input())
B = int(input())
if A*B > 0 :
    result = 1 if A > 0 else 3
else:
    result = 4 if A > 0 else 2
```

+ **삼항연산자**를 사용하면 매우 간단하게 나타낼 수 있다.
+ 전자의 경우는 조건 자체가 길기 때문에 삼항연산자를 사용하더라도 코드가 지저분해진다.

<br/>

## 2021-03-30

+ 백준 특강 문제들을 풀었다.
+ **제곱근, 소풍, 요세푸스 문제 3, 골드바흐 파티션**
+ 정말 한 문제도 풀지 못했다. 백준에서 각각 난이도 브론즈1, 실버2, 골드1, 플레티넘의 난이도를 하는 문제들이라고 한다.
+ 약간의 좌절감을 맛보았다... 주말에 다시 풀어냈으나 푸는 방법의 리뷰를 들은 것이라 나중에 잊혀질 때쯤 다시 도전해 봐야겠다.

<br/>

## 2021-04-09

+ 알고리즘 과목평가를 위한 대비 문제로 백준의 2178번을 풀었다.

+ **미로 탐색**

+ **BFS**의 알고리즘을 사용해 풀어야 하는 문제들이었다.

+ 주어진 미로의 좌상단에서 우하단까지 가는 최단 거리를 구하는 것이다.

  + 평소처럼 BFS로 풀었으나 시간 초과가 발생했다! -> 왜?

+ 평소의 풀이

  + ```python
    drc = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    N, M = map(int, input().split())
    arr = [list(map(int, input())) for _ in range(N)]
    visited = [[0]*M for _ in range(N)]
    queue = [(0, 0, 1)]
    while queue:
        r, c, cnt = queue.pop(0)
        if r == N - 1 and c == M - 1:
            print(cnt)
            break
        visited[r][c] = 1
        for dr, dc in drc:
            nr, nc = r + dr, c + dc
            if 0 <= nr < N and 0 <= nc < M and not visited[nr][nc] and arr[nr][nc]:
                queue.append((nr, nc, cnt+1))
    ```

  + 즉, queue안에 (행, 열, 거리)의 정보가 담기게 된다.

  + 혹시나 `deque()`를 사용하면 빨리 풀릴까 하여 `from collections import deque`를 하고 `queue = deque()`와 `queue.popleft()`를 사용해 풀어봤지만 이번엔 메모리 초과가 발생했다.

    + 'queue에 세 번째 값으로 거리를 하나 더 주는 것이 문제인가?'라는 생각을 했다.

+ 수정한 정답의 풀이

  + ```python
    from collections import deque
    
    
    drc = [[0, 1], [1, 0], [0, -1], [-1, 0]]
    N, M = map(int, input().split())
    arr = [list(map(int, input())) for _ in range(N)]
    visited = [[0]*M for _ in range(N)]
    queue = deque()
    queue.append((0, 0))
    visited[0][0] = 1
    while queue:
        r, c = queue.popleft()
        if r == N - 1 and c == M - 1:
            print(visited[N-1][M-1])
            break
        for dr, dc in drc:
            nr, nc = r + dr, c + dc
            if 0 <= nr < N and 0 <= nc < M and not visited[nr][nc] and arr[nr][nc]:
                queue.append((nr, nc))
                visited[nr][nc] = visited[r][c] + 1
    ```

  + 예상이 맞았다. 거리의 계산을 queue의 세 번째 값을 1씩 더해가며 구하는 것이 아닌, **visited**를 이용하여 BFS 한 단계마다 visited의 값을 1씩 늘려 저장하는 식으로 구현하니 문제가 없었다.

+ 느낀점 및 배운점

  + 처음 BFS를 통해 최단거리를 구하는 문제를 풀 때, queue의 세 번째 값으로 아예 거리값을 계속 갱신해서 넣어주는 풀이와 visited를 이용해서 visited가 1씩 누적하여 올라가는 풀이 두 가지를 배웠는데 무슨 차이인지 배우지는 않았었다.
  + 하지만 이번 문제를 통해서  값을 하나 더 넘겨주는 방식은 안전하지 않다는 것을 알았다.
    + 정말 안타깝게도 이유가 무엇인지는 잘 모르겠다.
    + python의 `time`을 통해서 두 가지 방법일 경우의 코드 실행시간을 찍어봤는데, 비슷하다...
      + 아마 테스트 케이스의 차이일 수도 있겠지만, 백준 내부의 테스트 케이스를 모르므로 일단은 재귀나 반복의 구조에서 가능하면 **데이터의 구조**를 건드리지 말고 값만 샥 바꿀 수 있는 것을 택하자.
        + 데이터의 구조란 queue를 말하는 것이고, 값이란 visited의 각 값을 말한 것

<br/>

## 2021-06-17

+ 백준의 15649, 1874, 2156, 14502번 문제를 풀었다.
+ **N과 M, 스택 수열, 포도주 시식, 연구소**
+ **순열, 스택, DP, DFS, BFS**의 알고리즘을 사용해 풀어야 하는 문제들이었다.
+ **N과 M**의 문제는 DFS를 이용한 순열 구현으로 쉽게 풀 수 있었다.
+ **스택 수열**은 스택을 이용해서 푸는 문제였는데, 문제풀이능력이 매우 중요했다.
  + 특정 변수를 만들어 사용하지 않으면 풀 수 없는 문제다.
  + 매우 괜찮은 문제라고 생각!
+ **포도주 시식**은 전형적인 DP문제였다. 헷갈리지 않고 DP의 점화식을 찾으면 쉽게 풀 수 있다.
+ **연구소**는 DFS와 BFS를 한 번에 사용해야 하는 문제로, 어떻게 구현이 되어야 하는 가만 머리에 잘 그리면 풀이가 가능하다.
  + 매우 어려운 문제였다.
+ 느낀점 및 배운점

  + 이번엔 생각보다 **스택 수열** 문제에서 많이 헤맸다. 차근차근 펜으로 구현 방식을 써가며 푸는 것이 좋을 것 같다.
  + **연구소** 문제는 처음으로 경험한 두 알고리즘을 제대로 섞은 문제였다. DFS의 내에서 BFS를 해야 하는 문제였는데, 앞으로 시뮬레이션 구현 문제에서 많이 활용될 수 있을 것 같다.

<br/>

## 2021-06-17

+ 백준의 17143번 문제를 풀었다.
+ **낚시왕**
+ 시뮬레이션을 구현하는 문제였다.
+ 시뮬레이션상 동시에 일어나는 일들을 코드 상에서는 동시 처리할 수 없기 때문에 이 부분을 어떻게 구현할 것인가가 관건이 되었다.
  + 매우 어려웠다. 하지만 겨우겨우 풀어냈다.
+ 느낀점 및 배운점

  + 보통 어려운 코딩 테스트는 이런 시뮬레이션 상황을 구현하는 문제가 나온다.
  + 스터디원들 중에는 가장 빨리 풀긴 했지만, 효율성이 조금 떨어지기 때문에 속도는 유지하면서도 어떻게 하면 더 효율적으로 짤 수 있을지 고려해봐야 할 것 같다.

<br/>

## 2021-06-24

+ 백준의 9466번 문제를 풀었다.
+ **텀 프로젝트**
+ 시간 복잡도를 신경써야 하는 문제였다.
+ 문제를 어떻게 풀어야 할지에 대한 해답을 찾기는 쉬우나, 이를 Python 코드로 구현하였을 때 어떤 자료 구조를 사용함으로써 시간 복잡도를 줄일 수 있는지 잘 따져봐야 한다.
  + 리스트는 원소를 순회하는데 O(n)이 걸리기 때문에 이 문제에서 우리에게 익숙한 리스트를 사용하면 시간 초과가 발생한다.
  + 셋과 딕셔너리는 원소를 순회하는데 O(1)의 시간이 걸린다.
  + 즉, 셋과 딕셔너리를 사용함과 동시에 문제를 파악하여 **가지치기**를 잘 해야 통과할 수 있다.
  + **우리 팀만 풀이를 성공했다!**
+ 느낀점 및 배운점

  + 코드를 총 4번 정도 수정하면서 실행 시간을 계속 줄여 나갔다. 확실히 생각이 깊어지고 원리를 따지니 코드가 점점 더 좋아진다.
  + 가독성이 높고 파이써닉한 코드를 짜려고 노력하자.

<br/>

## 2021-06-26

+ 백준의 1138번 문제를 풀었다.
+ **한 줄로 서기**
+ 주어진 정보를 통해 사람들의 줄 순서를 찾아야 하는데, 규칙을 찾는 문제였다.
+ 앞 사람의 정보에 의해서 뒷 사람의 위치를 알 수 있으므로 차근차근 주어진 데이터를 순서대로 처리하면 된다.
  + 이 규칙을 찾지 못하면 매우 헤멜 수 있는 문제다.
  + 아마 순서대로 자리를 확정해나가지 않고 모든 데이터를 통해서 계속 서로의 자리를 바꿔나가는 식으로 짠다면 시간 초과가 발생할 것이다.
+ 느낀점 및 배운점

  + 완전 탐색의 문제와 규칙을 찾아서 적절한 알고리즘을 짜는 문제의 차이가 점점 눈에 들어온다.
  + 문제를 확실하게 이해하고 푸는 연습을 더 많이 하자.

<br/>

## 2021-06-27

+ 백준의 1260번 문제를 풀었다.
+ **DFS와 BFS**
+ DFS와 BFS의 알고리즘을 사용하면서, 문제에서 주어진 조건에 맞게 이 알고리즘들을 잘 변형해 사용해야하는 문제였다.
+ DFS와 BFS의 탐색에서 모두 인접 정점들을 방문할 때는 무조건 번호가 낮은 정점부터 방문한다.
  + 즉, 인접 리스트를 오름차순 해놨다면 queue를 사용하는 BFS에서는 그대로 정점을 앞부터 읽고, stack을 사용하는 DFS에서는 정점을 역순으로 읽어와야 한다는 것을 찾아야 한다.
  + 그 후, visited의 처리를 어디서 해줘야 하는지도 중요하다. DFS의 경우 인접 정점을 읽는 곳에서 미리 visited 처리를 해주는 것이 아닌, 해당 정점을 읽어오는 바로 그 때에 visited 처리를 해주어야만 오류가 발생하지 않는다. 이는 DFS의 처리 방식과 다르게 이미 정점들을 고정된 순서로 읽었기 때문이다.
+ 느낀점 및 배운점

  + 이렇게 기본적인 알고리즘을 가지고 그 알고리즘을 적절히 변형하여 풀 수 있게 하는 문제는 참 좋은 것 같다. 기본기를 다시 한 번 다지면서도 생각의 확장이 이루어지게 한다.
  + 백준을 티어별로 풀기 위해 S2 난이도부터 몇 개 풀어본 결과, S2로 시작하면 무난하게 많은 것들을 배울 수 있을 것 같다.

<br/>

## 2021-07-01

+ 백준의 16235번 문제를 풀었다.
+ **나무 재테크**
+ 시뮬레이션을 구현하는 문제로, 시간 복잡도 때문에 python collections의 deque를 사용해야했다.
+ 느낀점 및 배운점

  + 문제 자체와 로직은 어렵지 않기 때문에 따로 리뷰할 것이 없다. 다만, 이 문제에서 시간 초과 때문에 고생을 많이 하면서 배운 것이 있다.
  + 딕셔너리를 보통 시간 복잡도를 줄일 수 있다고 많이 생각하지만, 이 딕셔너리에서 원소 삭제, 원소 존재 확인 같이 리스트와 비교하여 확실한 시간 절약을 갖는 기능을 쓰지 않는 이상 리스트보다 좋을 것이 절대 없다. 오히려 딕셔너리로의 변환, 생성 등에서 시간을 더 잡아먹는다. 결국 나는 이 딕셔너리를 사용했을 때는 전부 통과하지 못했다.
  + 리스트를 사용하면서 리스트의 앞에 원소를 넣는 과정이 필요할 때는 고민하지 말고 deque를 쓰자. Collections는 충분히 사용해도 되는 기능이기 때문에 시간 복잡도 문제에서 앞으로 많이 사용하게 될 것 같다.

<br/>

## 2021-07-15

+ 백준의 11047번 문제를 풀었다.
+ **동전**
+ **그리디** 기법을 사용했다.
+ 이런 문제는 조건을 잘 따져봐야 한다. 그리디를 사용하는 문제에서 조건에 따라 knapsack과 같은 DP 문제로 난이도가 급상승할 수 있기 때문이다. 다행히 이 문제에서는 입력 조건을 보면 동전들이 이전 단위의 배수로 주어지는 것을 알 수 있다. 따라서, 동전의 단위가 애매하게 겹쳐 그리디가 실패하는 일이 없다.
+ 느낀점 및 배운점

  + 그리디를 마주하면 항상 불안하다. 조건을 파악하면서 이것이 DP인지를 확인하는 능력도 필요하다.

<br/>

## 2021-07-16

+ 백준의 2667번 문제를 풀었다.
+ **단지번호**
+ **BFS** 기법을 사용했다.
+ 그래프를 입력 받아 BFS를 활용하여 적절한 곳에 변수를 넣고 원하는 값을 뽑아내기만 하면 된다. 
+ 느낀점 및 배운점

  + BFS를 오랜만에 다시 마주했는데, 이젠 확실히 오랜만에 봐도 알고리즘이 잘 기억나는 것 같다. 다른 것도 마스터하자!

<br/>

## 2021-07-22

+ 백준의 2234번 문제를 풀었다.

+ **성곽**

+ **DFS, 딕셔너리 활용** 기법을 사용했다.

+ 이 문제는 간단히 벽으로 막힌 이중배열을 주고, 벽으로 둘러싸인 방의 개수와 크기를 구하는 문제다. 여기까지는 간단히 BFS나 DFS로 풀 수 있지만, 문제는 3번째 조건인 **한 벽을 부수고 두 방을 연결하여 가장 큰 방의 크기를 구하는 것**이다. 

  + 실제로 벽을 뚫는 것을 구현하는 것은 어렵다. 벽을 뚫어서 갈 수 있다는 것은 두 방이 인접해있다는 뜻이다.
  + 즉, 인접한 방의 크기의 합을 구하는 방법으로 푼다.
  + 이를 위해 visited 배열을 각 방의 고유 번호로 채울 것이다. 그리고 visited 배열에서 인접한 칸의 번호가 다르면 두 방이 인접한 것이다. 그러한 두 방의 크기를 합친 것들 중 가장 큰 값을 구하면 된다.
  + {각 방의 고유 번호 : 각 방의 크기}의 구조를 갖는 딕셔너리를 만든다.
  
+ 느낀점 및 배운점

  + 요즘 딕셔너리를 활용해서 어려운 부분을 쉽게 구현해야 하는 문제들이 많이 나왔다. 이번 문제에서 내가 풀면서도 가장 좋았던 발상은 **'한 벽을 뚫는 것은 결국 두 방이 인접해있다는 것이므로 각 방의 고유 숫자를 정해주고, 인접한 두 칸의 고유한 숫자가 다르면 인접한 것이다'**였다. 이 덕분에 문제를 쉽고도 빠르게 풀 수 있었던 것 같다.
  + 이제는 알고리즘 자체보다는 정말 **발상**이 중요함을 깨닫는다. 더욱 많은 경험을 하는 것이 좋을 것 같다.

<br/>

## 2021-10-03

+ 백준의 10866, 2193, 1991번 문제를 풀었다.
+ **덱, 이친수, 트리 순회**
+ **리스트, dp, 트리** 기법을 사용했다.
+ **덱**의 경우 python의 collections에서 deque를 이용해 할 수 있는 기능들을 직접 구현해보는 문제였다.
  + 덱은 큐와 비슷한 자료구조로, 앞과 뒤에서 모두 삽입과 삭제가 가능한 자료구조라고 한다.
  + 물론 내가 만든 덱의 경우 pop(0)을 쓰기 때문에 실제 collections의 deque보다 시간 복잡도는 더 크다.
  + 덱의 기본 작동 개념 정도만 알고 간다는 느낌으로 하자.
+ **이친수**의 경우 몇가지 상황에 대해 답을 구하다 보면 현재의 답이 이전의 결과들에 따라서 결정됨을 알 수 있다. 따라서 dp로 해결한다.
+ **트리 순회**의 경우 전위 순회, 중위 순회, 후위 순회의 결과를 모두 출력하는 문제다. 이런 문제의 경우 각각의 함수를 만들어줄 필요없이 순회 함수를 하나만 만들고 전위, 중위, 후위 부분에 결과를 저장해두는 로직을 짜면 된다. 코드가 훨씬 짧고 가독성이 높아진다.
+ 느낀점 및 배운점

  + 프로젝트로 인해 오랜 기간 알고리즘 스터디를 못하다가 간만에 조금 쉬운 문제들을 풀어보았다. 기초가 되는 문제들이고, 특히 덱이라는 자료구조에 대해서 추가로 알아보았는데 많은 도움이 될 것 같다.

<br/>

## 2021-10-14

+ 백준의 1003번 문제를 풀었다.
+ **피보나치 함수**
+ **dp** 기법을 사용했다.
+ 이번 신한은행 코딩 테스트를 보고 어려운 dp문제를 만나 1시간이나 끙끙 앓다가 결국 점화식을 못찾고 풀지 못했다. dp를 배운지 너무 오래 된 것 같다.
+ 이제 백준의 dp와 관련된 단계별 문제들을 풀어나갈 것이다.
+ 이 문제 또한 단순히 재귀로 구현하면 시간초과가 나고, dp로 구현해야만 해결할 수 있는 문제였다.
+ 느낀점 및 배운점

  + dp 마스터하자.

<br/>

## 2021-11-26

+ 백준의 17298번 문제를 풀었다.
+ **오큰수**
+ **스택**을 사용했다.
+ 문제만 딱 봤을 때는 '2중 for문으로 그냥 풀면 되는 것 아닌가?'라고 생각할 수 있지만, 문제에서 주어진 조건이 리스트의 길이가 백만이기 때문에 2중으로 for문일 경우 제한 시간 초과가 발생하게 된다.
+ 결국 이 문제는 우리가 간단히 구현하고 넘어갈 수 있는 문제를 보다 좋은 알고리즘으로 O(n)으로 바꿔버리는 정말 좋은 문제이다.
+ 지문을 직접 봐야 문제를 이해할 수 있을 것이다. 지문을 읽고 나면, 주어진 리스트를 거꾸로부터 쌓아서 스택 구조를 통해 top에 있는 숫자보다 작은 경우의 숫자만 새로 쌓는 것이 필요하다는 것을 알 수 있다.
  + 즉, top에 있는 숫자가 새로 들어오는 숫자보다 작다면 pop으로 없애버린다.
+ 느낀점 및 배운점

  + 이런 문제가 재밌다. 너무나도 쉬워 보이는 문제이지만 머리를 쓴다면 훨씬 효율적인 방법으로 풀이를 할 수 있다.
  + 어려웠지만 이런 문제를 자주 만나고 싶다.
